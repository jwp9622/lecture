#
## Day 7 :  사용자 계정 관리 및 권한 기반 요청 제한(Talend 기반)
* 강의 목표  
사용자 엔티티 설계 및 회원가입 API 구현  
Spring Security를 통한 권한(Role) 부여 및 보호 API 설정  
Talend를 통해 사용자 권한 테스트 시나리오 검증  
  
* 강의 내용  
1. 사용자 엔티티 및 회원가입 API 설계  
2. 비밀번호 암호화 처리(BCryptPasswordEncoder)  
3. Spring Security에서 권한 부여 및 URL 보호 설정  
4. Talend를 통해 역할별 접근 제한 테스트  
  
* 실습 코드 : 회원가입 및 권한 설정  
User.java

        package com.example.jwt.model;
        @Entity
        public class User{
          private Long id;
          private String username;
          private String password;
          private String role; //ROLE_USER, ROLE_ADMIN
          //getters/setters
        }

* UserRepository.java

        package com.example.jwt.repository;
        import com.exmaple.jwt.model.User;
        import org.springframework.data.jpa.repoistory.JpaReository;
        import java.util.Optional;

        public interface UserRepository extends JpaRepository<User, Long>{
          Optional<User> findByUsername(String username);
        }

* RegisterRequest.java

        package com.example.jwt.dto;
        public class RegisterRequest{
          private String username;
          private String password;
          private String role; //ROLE_UER or ROLE_ADMIN
          //getters/setters
        }

* AuthController.java(회원가입 추가)

        @PostMapping("/register")
        public ResponseEntity<?> register(@RequestBody RegisterRequest request){
          String ecodedPw = passwordEncoder.encode(request.getPassword());

          User user = new User();
          user .setUsername(request.getUername());
          user.setPassword(encodedPw)
          user.setRole(request.getRole)
          userRepository.save(user);

          return ResponseEntity.ok("회원가입 완료");
        }

* SecurityConfig.java(권한별 접근 설정)

        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
          http.csrf().disable()
              .authorizeHttpRequests()
              .requestMatchers("/auth/**").permitAll()
              .requestMatchers("/admin/**").hasRole("ADMIN")
              .anyRequest().authenticated()
              .and()
              .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
          return http.build();
        }

* 예시 : Admin전용 API

        @GetMapping("/admin/dashboard")
        public ResponseEntity<String> adminDashboard(){
          reutrn ResponseEntity.ok("관리자 페이지입니다.");
        }

* Day 7 과제

📂 프로젝트 구조 요약

        com.example.jwt
        ├── JwtApplication.java
        ├── controller
        │   └── AuthController.java
        │   └── AdminController.java
        ├── dto
        │   └── RegisterRequest.java
        │   └── LoginRequest.java
        ├── model
        │   └── User.java
        ├── repository
        │   └── UserRepository.java
        ├── config
        │   └── SecurityConfig.java
        ├── util
        │   └── JwtUtil.java
        ├── filter
        │   └── JwtAuthenticationFilter.java


1. /auth/register를 통해  Talend로 사용자 2명 등록 : USER, ADMIN 권한 각각 부여

2. 로그인하여 JWT 토큰 발급 --> Authorization 헤더로 /admin/dashboard 요청 테스트

3. ROLE_USER 계정이 관리자 API에 접근한 경우 403 응답이 발생하는지 확인

4. Security 설정에서 권한 별 URL 보호가 실제로 동작하는지 확인하고 문서화


* JwtAuthenticationFilter

        // filter/JwtAuthenticationFilter.java
        package com.example.jwt.filter;

        import com.example.jwt.util.JwtUtil;
        import io.jsonwebtoken.Claims;
        import jakarta.servlet.*;
        import jakarta.servlet.http.*;
        import org.springframework.security.authentication.*;
        import org.springframework.security.core.context.SecurityContextHolder;
        import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
        import org.springframework.stereotype.Component;
        import org.springframework.web.filter.OncePerRequestFilter;

        import java.io.IOException;

        @Component
        public class JwtAuthenticationFilter extends OncePerRequestFilter {

            private final JwtUtil jwtUtil;

            public JwtAuthenticationFilter(JwtUtil jwtUtil) {
                this.jwtUtil = jwtUtil;
            }
        @Override
            protected void doFilterInternal(HttpServletRequest request,
                                            HttpServletResponse response,
                                            FilterChain filterChain)
                    throws ServletException, IOException {

                String header = request.getHeader("Authorization");
                if (header != null && header.startsWith("Bearer ")) {
                    String token = header.substring(7);
                    Claims claims = jwtUtil.validateToken(token);

                    if (claims != null) {
                        UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
                                claims.getSubject(), null, null
                        );
                        auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(auth);
                    }
                }

                filterChain.doFilter(request, response);
            }
        }


* SecurityConfig 설정

        // config/SecurityConfig.java
        package com.example.jwt.config;

        import com.example.jwt.filter.JwtAuthenticationFilter;
        import org.springframework.context.annotation.*;
        import org.springframework.security.authentication.*;
        import org.springframework.security.config.annotation.web.builders.HttpSecurity;
        import org.springframework.security.config.http.SessionCreationPolicy;
        import org.springframework.security.crypto.bcrypt.*;
        import org.springframework.security.web.*;
        import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

        @Configuration
        public class SecurityConfig {

            private final JwtAuthenticationFilter jwtAuthenticationFilter;

            public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
                this.jwtAuthenticationFilter = jwtAuthenticationFilter;
            }
        @Bean
            public PasswordEncoder passwordEncoder() {
                return new BCryptPasswordEncoder();
            }

            @Bean
            public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
                http.csrf().disable()
                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                    .and()
                    .authorizeHttpRequests()
                    .requestMatchers("/auth/**").permitAll()
                    .requestMatchers("/admin/**").hasRole("ADMIN")
                    .anyRequest().authenticated()
                    .and()
                    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

                return http.build();
            }
        }


* 주의사항  
  
  DB에 저장되는 role은 ROLE_ADMIN  
  
  hasRole("ADMIN")은 내부적으로 ROLE_ prefix가 붙는 것을 기대함  
> Talend 테스트 시나리오  
  
* 사용자 등록 (일반 사용자)  
  
POST /auth/register  
{  
  "username": "user1",  
  "password": "pass1",  
  "role": "ROLE_USER"  
}  

  
* 관리자 등록  
  
POST /auth/register  
{  
  "username": "admin1",  
  "password": "pass2",  
  "role": "ROLE_ADMIN"  
}  


* 로그인 요청  
  
POST /auth/login  
{  
  "username": "admin1",  
  "password": "pass2"  
}  
  
✔ 응답: Bearer eyJhbGci...  


* 관리자 페이지 요청  
  
GET /admin/dashboard  
Authorization: Bearer {토큰}  
  
user1 → 403 Forbidden  
  
admin1 → 200 OK, 본문: "관리자 페이지입니다"  



> 요약 정리  
  
사용자 등록 ---> ✔ 정상  
  
로그인 → JWT 발급 ---> ✔ 정상  
  
관리자 URI 보호 ---> ✔ ROLE_USER 접근 시 차단  
    
SecurityConfig 작동 ---> ✔ 경로별 권한 동작  
  
Talend 테스트 ---> ✔ 완료  
  


## Day 7 객관식 문제

1. Spring Security에서 URL마다 접근 권한을 제어하려면 어떤 설정 파일에서 이를 정의하는가? C
 A. application.properties  
 B. JwtUtil.java  
 C. SecurityConfig.java  
 D. WebConfig.java  
  
2. 회원가입 시 비밀번호는 어떻게 저장하는 것이 가장 안전한가? D  
 A. 평문 그대로 저장  
 B. MD5로 해시  
 C. Base64 인코딩  
 D. BCrypt로 암호화  
  
3. 아래 중 ROLE_ADMIN 사용자만 접근 가능한 URI는? C  
 A. /auth/login  
 B. /auth/register  
 C. /admin/dashboard  
 D. /user/profile  
  
4. Spring Security의 hasRole("ADMIN") 설정은 내부적으로 어떤 권한 문자열을 기대하는가? C  
 A. ADMIN  
 B. user:ADMIN  
 C. ROLE_ADMIN  
 D. /ADMIN  
  
5. JWT 토큰을 Authorization 헤더에 보낼 때 사용하는 접두사는? C  
 A. Token  
 B. JWT  
 C. Bearer  
 D. Access  
  
6. SecurityFilterChain에서 인증 필터를 등록할 때 사용되는 메서드는? B  
 A. addFilter  
 B. addFilterBefore  
 C. addAuthenticationFilter  
 D. addSecurityFilter  
  
7. 사용자 인증 정보를 SecurityContextHolder에 저장하려면 어떤 객체를 만들어야 하는가? B  
 A. UserDetails  
 B. UsernamePasswordAuthenticationToken  
 C. PrincipalDetails  
 D. AuthProvider  
  
8. 아래 중 JwtUtil의 기능이 아닌 것은?D  
 A. 토큰 생성  
 B. 토큰 서명  
 C. 토큰 검증  
 D. 비밀번호 암호화  
  
9. JwtAuthenticationFilter는 어떤 메서드를 오버라이드하여 동작하는가? B  
 A. doPost()  
 B. doFilterInternal()  
 C. run()  
 D. handleRequest()  
  
10. 인증되지 않은 사용자가 /admin/dashboard에 접근하면 발생하는 HTTP 상태 코드는? D  
 A. 401 Unauthorized  
 B. 200 OK  
 C. 500 Internal Server Error  
 D. 403 Forbidden  
  
11. SecurityFilterChain에서 /auth/** 경로에 대해 .permitAll()을 사용하는 이유는? B  
 A. 로그인한 사용자만 접근하게 하기 위해  
 B. 누구든 접근할 수 있도록 허용하기 위해  
 C. 관리자만 접근 가능하도록 하기 위해  
 D. 인증이 필요 없음을 명시하기 위해  
  
12. Talend API 테스트에서 ROLE_USER로 로그인한 사용자가 /admin/dashboard를 요청하면? B  
 A. 200 OK  
 B. 403 Forbidden  
 C. 404 Not Found  
 D. 302 Redirect  
  
13. JWT 토큰의 claim에 들어가는 주요 정보는 무엇인가? C  
 A. 사용자 아이디, 역할, 비밀번호  
 B. 요청 URI  
 C. 토큰의 subject, 발급일, 만료일  
 D. 응답 코드  
  
14. @PostMapping("/register")가 의미하는 것은? C  
 A. HTTP GET 요청 처리  
 B. HTML form 렌더링  
 C. HTTP POST 요청 처리  
 D. PUT 요청 처리  
  
15. 다음 중 인증 필터보다 먼저 동작하게 설정하려면 어떤 클래스를 앞에 추가해야 하는가? C  
 A. JwtUtil  
 B. PasswordEncoder  
 C. JwtAuthenticationFilter  
 D. SecurityContext  
  
16. 비밀번호 비교 시 사용하는 메서드는? C  
 A. encode()  
 B. match()  
 C. matches()  
 D. checkPassword()  
  
17. 아래 코드 중 인증 필터 등록 방식은? C  
 A. .addFilter(jwtAuthenticationFilter)  
 B. .addFilterAfter(jwtAuthenticationFilter, ...)  
 C. .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)  
 D. .use(jwtAuthenticationFilter)  
  
18. 사용자 등록 시 저장되는 권한(role)은 어떤 형식인가? C  
 A. 그냥 ADMIN  
 B. ADMIN_ROLE  
 C. ROLE_USER 또는 ROLE_ADMIN  
 D. USER/ADMIN  
  
19. JWT가 유효한지 검증하려면 어떤 클래스가 필요할까? C  
 A. Claims  
 B. JwtTokenValidator  
 C. JwtUtil  
 D. JwtGenerator  
  
20. @RestController의 역할은? C  
 A. HTML 응답 제공  
 B. Spring MVC View 렌더링  
 C. JSON/REST 응답 처리  
 D. 데이터베이스 연동 처리  

## Day 7 객관식 정답 및 해설
1. 번 정답: C   
 SecurityConfig.java에서 HttpSecurity를 통해 URL 접근 권한을 설정합니다.
2. 정답: D  
 BCryptPasswordEncoder는 Spring Security에서 안전한 비밀번호 암호화 방식입니다.  
3. 정답: C  
 /admin/dashboard는 관리자만 접근 가능한 URL입니다.  
4. 정답: C  
 hasRole("ADMIN")은 내부적으로 ROLE_ADMIN을 기대합니다.  
5. 정답: C  
 JWT 토큰은 Authorization: Bearer {토큰} 형식으로 전송됩니다.  
6. 정답: B  
 JWT 인증 필터는 UsernamePasswordAuthenticationFilter보다 앞에 등록해야 하므로 addFilterBefore를 사용합니다.  
7. 정답: B  
 SecurityContextHolder에 인증 정보를 저장하려면 UsernamePasswordAuthenticationToken을 사용합니다.  
8. 정답: D  
 비밀번호 암호화는 PasswordEncoder가 담당하며 JwtUtil은 JWT 생성 및 검증만 합니다.  
9. 정답: B  
 JwtAuthenticationFilter는 OncePerRequestFilter의 doFilterInternal()을 오버라이드합니다.  
10. 정답: D  
 인증은 되었지만 권한이 부족하면 403 Forbidden이 발생합니다.  
11. 정답: B  
 .permitAll()은 누구든 접근 가능하도록 허용하는 설정입니다.  
12.  정답: B  
 ROLE_USER 권한으로 /admin/dashboard에 접근 시 403 Forbidden이 응답됩니다.  
13.  정답: C  
 JWT Claims에는 사용자 이름, 발급일(issuedAt), 만료일(expiration) 등의 정보가 담깁니다.  
14. 정답: C  
 @PostMapping("/register")는 HTTP POST 요청을 처리하는 엔드포인트입니다.  
15. 정답: C  
 JWT 인증 필터는 UsernamePasswordAuthenticationFilter보다 앞에 추가해야 하므로   addFilterBefore()로 등록합니다.  
16. 정답: C  
 PasswordEncoder.matches()를 통해 암호화된 비밀번호와 입력값을 비교합니다.  
17. 정답: C  
 인증 필터는 addFilterBefore()를 통해 등록하고 인증 순서를 지정합니다.  
18. 정답: C  
 Spring Security에서는 "ROLE_USER" 또는 "ROLE_ADMIN" 형식으로 권한을 저장합니다.  
19. 정답: C  
 토큰 유효성 검증은 JwtUtil.validateToken() 메서드에서 수행됩니다.  
20. 정답: C  
 @RestController는 REST API 응답을 JSON 형식으로 반환하는 컨트롤러입니다.   



## Day 7 단답형 문제

1. Spring Security에서 URL 접근 권한을 설정하는 클래스 이름은?

2. 사용자의 비밀번호를 암호화할 때 사용하는 Spring Security 클래스는?

3. hasRole("ADMIN")이 인식하는 권한 이름은?

4. /admin/dashboard 경로에 접근 가능한 권한은?

5. JWT 토큰을 HTTP 요청에 담을 때 사용하는 HTTP 헤더는?

6. JWT 토큰 앞에 붙는 접두사는?

7. 인증이 완료된 사용자 정보를 저장하는 Spring Security의 컨텍스트는?

8. 사용자 인증 객체를 생성할 때 사용하는 토큰 클래스 이름은?

9. JwtAuthenticationFilter에서 필터 체인에 연결하기 위해 오버라이드하는 메서드 이름은?

10. 로그인 요청 시 클라이언트에 전달되는 응답 값은 무엇인가?

11. 로그인 성공 후 발급되는 인증 수단은?

12. 회원가입 API에서 사용자의 권한(역할)을 저장하는 필드 이름은?

13. 사용자의 권한을 설정할 때 반드시 포함해야 하는 접두어는?

14. 권한이 없는 사용자가 관리자 페이지에 접근할 경우 발생하는 HTTP 상태 코드는?

15. 사용자 인증 필터는 어떤 기본 필터보다 먼저 등록되어야 하는가?

16. 사용자 인증 후 인증 객체를 등록하는 보안 컨텍스트 클래스는?

17. 토큰이 유효한지를 검사하는 JwtUtil 메서드의 이름은?

18. Security 설정에서 인증 없이 접근을 허용하는 메서드는?

19. JWT 토큰의 내부 정보(Claims)에서 사용자의 이름을 저장하는 필드는?

20. Spring Boot에서 REST API 응답을 JSON으로 처리하기 위해 사용하는 컨트롤러 어노테이션은?

## Day 7 단답형 문제 정답 + 해설

1. 정답: SecurityConfig.java
 → Spring Security에서 URL 접근 권한 설정은 HttpSecurity 객체를 설정하는 SecurityConfig 클래스에서 합니다.
2. 정답: BCryptPasswordEncoder
 → 비밀번호를 안전하게 암호화하기 위해 Spring Security에서 기본으로 제공하는 클래스입니다.
3. 정답: ROLE_ADMIN
 → hasRole("ADMIN")은 내부적으로 ROLE_ADMIN이라는 문자열을 사용해 권한을 검사합니다.
4. 정답: ROLE_ADMIN
 → /admin/** 경로는 관리자 권한을 가진 사용자만 접근할 수 있도록 설정됩니다.
5. 정답: Authorization
 → JWT 토큰은 HTTP 헤더 중 Authorization에 포함되어 서버로 전송됩니다.
6. 정답: Bearer
 → JWT 토큰은 "Bearer " 접두어와 함께 전송됩니다. (Bearer {token} 형식)
7. 정답: SecurityContextHolder
 → 인증된 사용자 정보를 저장하는 Spring Security의 전역 컨텍스트입니다.
8. 정답: UsernamePasswordAuthenticationToken
 → 인증이 완료된 사용자의 정보를 담아 SecurityContext에 등록할 때 사용하는 인증 객체입니다.
9. 정답: doFilterInternal
 → JWT 필터 클래스는 OncePerRequestFilter를 상속하고 이 메서드를 오버라이드해 동작합니다.
10. 정답: JWT 토큰
 → 로그인 성공 시 서버는 클라이언트에게 JWT 토큰을 반환합니다.
11. 정답: JWT
 → JWT는 로그인 이후 API 접근을 위해 사용하는 인증 토큰입니다.
12. 정답: role
 → 회원가입 시 요청 DTO에 포함되는 필드로 사용자 권한을 의미합니다. 예: ROLE_USER, ROLE_ADMIN
13. 정답: ROLE_
 → Spring Security는 권한명 앞에 "ROLE_"이 붙어 있어야 인식합니다.
14. 정답: 403
 → 인증은 되었지만 권한이 부족한 경우 403 Forbidden 상태 코드가 응답됩니다.
15. 정답: UsernamePasswordAuthenticationFilter
 → JWT 인증 필터는 이 필터보다 먼저 동작해야 하기 때문에 addFilterBefore()로 등록합니다.
16. 정답: SecurityContextHolder
 → 인증 객체는 이 컨텍스트에 저장되어 전역적으로 참조됩니다.
17. 정답: validateToken
 → JwtUtil 클래스에서 토큰의 유효성을 검사하는 메서드입니다.
18. 정답: permitAll
 → 인증 없이 접근을 허용할 URL 패턴에 이 메서드를 사용합니다.
19. 정답: sub
 → JWT Claims 내에 사용자 식별자는 일반적으로 subject(sub) 필드에 저장됩니다.
20. 정답: @RestController
 → 이 어노테이션을 사용하면 JSON 형식의 REST API 응답이 기본으로 제공됩니다.



 ## Day 7 프로그램 실습형 문제 10문제

문제 1   
User 엔티티 클래스를 작성하세요.   
username, password, role 필드를 포함하고   
   
@Entity, @Id, @GeneratedValue 어노테이션을 사용해 JPA 매핑을 완료하세요.   
   
   
   
문제 2   
UserRepository 인터페이스를 작성하고,   
 findByUsername(String username) 메서드를 선언하세요.   
   
문제 3   
RegisterRequest DTO를 생성하고   
 username, password, role 필드를 정의하세요.   
   
문제 4   
AuthController에 /auth/register POST 요청을 처리하는 메서드를 추가하세요.   
요청 받은 사용자 정보를 저장하고   
   
   
비밀번호는 BCryptPasswordEncoder를 사용하여 암호화한 뒤 저장하세요.   


문제 5
SecurityConfig 클래스에서 다음과 같이 경로별 접근 권한을 설정하세요.   
/auth/**는 모두 허용   
   
   
/admin/**은 ROLE_ADMIN만 허용   
   
   
나머지 요청은 인증된 사용자만 허용   
   
   
   
문제 6   
Talend API Tester를 이용하여 다음 JSON으로 일반 사용자 계정을 등록해보세요.   
{   
  "username": "user1",   
  "password": "pass1",   
  "role": "ROLE_USER"   
}   
   
   
문제 7   
Talend를 이용해 관리자 계정을 등록해보세요.   
{   
  "username": "admin1",   
  "password": "pass2",   
  "role": "ROLE_ADMIN"   
}   


문제 8   
/auth/login 요청을 통해 위 두 계정에 대해 JWT 토큰을 발급받고,   
 Authorization: Bearer {토큰}을 헤더에 포함하여 다음 요청을 각각 시도하세요:   
URL: /admin/dashboard   

   
사용자: user1 → 응답이 403인지 확인   
   

사용자: admin1 → 응답이 200이고 "관리자 페이지입니다"가 반환되는지 확인   
   


문제 9   
Security 설정에서 hasRole("ADMIN")으로 설정했을 때,   
 권한 필드가 "ROLE_ADMIN"으로 저장돼야 하는 이유를 설명해보세요.   
      
    

문제 10   
위 실습을 정리한 보고서를 작성하세요.   
등록된 사용자 목록   
   
JWT 응답과 권한 확인 스크린샷   

   
403 응답 캡처   

   
Security 설정 파일 코드 일부 포함   


## Day 7 문제 풀이

문제 1
User 엔티티 클래스 작성
        package com.example.jwt.model;

        import jakarta.persistence.*;

        @Entity
        public class User {

            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String username;
            private String password;
            private String role; // ROLE_USER 또는 ROLE_ADMIN

            // Getters & Setters
        }


문제 2
UserRepository 인터페이스 작성
        package com.example.jwt.repository;

        import com.example.jwt.model.User;
        import org.springframework.data.jpa.repository.JpaRepository;

        import java.util.Optional;

        public interface UserRepository extends JpaRepository<User, Long> {
            Optional<User> findByUsername(String username);
        }

문제 3
RegisterRequest DTO 생성

        package com.example.jwt.dto;

        public class RegisterRequest {
            private String username;
            private String password;
            private String role;

            // Getters & Setters
        }


문제 4
회원가입 API (/auth/register) 구현

        @PostMapping("/register")
        public ResponseEntity<?> register(@RequestBody RegisterRequest request) {
            String encodedPassword = passwordEncoder.encode(request.getPassword());

            User user = new User();
            user.setUsername(request.getUsername());
            user.setPassword(encodedPassword);
            user.setRole(request.getRole());

            userRepository.save(user);

            return ResponseEntity.ok("회원가입 완료");
        }

--> passwordEncoder는 BCryptPasswordEncoder 빈으로 주입되어야 합니다.

문제 5
SecurityConfig에서 권한별 접근 설정

        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http.csrf().disable()
                .authorizeHttpRequests()
                .requestMatchers("/auth/**").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
                .and()
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

            return http.build();
        }   
   
hasRole("ADMIN")은 내부적으로 ROLE_ 접두사가 붙으므로, 데이터에는 "ROLE_ADMIN"으로 저장해야 합니다.   
   

문제 6   
Talend로 일반 사용자 등록   
        Method: POST   
   
        URL: http://localhost:8080/auth/register   
   
        Body:   
   
        {   
          "username": "user1",   
          "password": "pass1",   
          "role": "ROLE_USER"   
        }   
   
        ✔ 응답: "회원가입 완료"   
   
   
문제 7   
Talend로 관리자 계정 등록   
        Method: POST   
   
        Body:   
   
        {   
          "username": "admin1",   
          "password": "pass2",   
          "role": "ROLE_ADMIN"   
        }   
   
        ✔ 응답: "회원가입 완료"   



문제 8
JWT 토큰 발급 및 권한별 요청 테스트   
        로그인 /auth/login      
   
        {   
          "username": "user1",   
          "password": "pass1"   
        }   

        → 응답: "Bearer eyJhbGciOi..."   
        관리자 요청 /admin/dashboard   
   
        Header:
      
        Authorization: Bearer {토큰}   

        user1 요청 결과: 403 Forbidden   
   
        admin1 요청 결과: 200 OK, 응답 본문: "관리자 페이지입니다"   


문제 9   
        hasRole("ADMIN") vs ROLE_ADMIN 설명   
        Spring Security의 hasRole("ADMIN")는 내부적으로 ROLE_ 접두사를 자동으로 붙여서 "ROLE_ADMIN"과 비교합니다.   
   

        그래서 DB에는 ROLE_ADMIN 형식으로 저장되어야 hasRole("ADMIN")로 검증이 됩니다.   
   
   
   
문제 10   
정리 보고서 예시   
사용자 목록   
   
        user1 (ROLE_USER)   
   
        admin1 (ROLE_ADMIN)   
   
        JWT 응답 캡처   
   
        sub, iat, exp 포함된 토큰   
   
        403 응답 스크린샷   
   
        user1 → /admin/dashboard 요청 시 차단됨   
   
        코드 스니펫   
   
        .requestMatchers("/admin/**").hasRole("ADMIN")   



