# Day 6 : JWT 필터와 사용자 권한 적용(Talend 기반)

* 강의 목표   
JWT 토큰을 검증하는 필터 구현  
사용자 인증 후 권한 부여 흐름 이해  
Spring Security에서 요청 필터 흐름 파악  
Talend API Tester로 Authorization헤더 테스트  

* 강의 내용  
JWT 인증 필터 구조 이해(OncePerRequestFilter)
SecurityContext에 인증 정보 저장
/posts 등 보호된 리소스 접근 시 인증 필터 적용
Talend를 통해 Bearer 토큰 포함 요청 실습

* 실습 코드 : JWT 인증 필터 적용
JwtAuthenticationFilter.java

        package com.example.project.global.security;

        import com.example.project.global.security.util.JwtUtil;
        import io.jsonwebtoken.Claims;
        import jakarta.servlet.FilterChain;
        import jakarta.servlet.ServletException;
        import jakarta.servlet.http.HttpServletRequest;
        import jakarta.servlet.http.HttpServletResponse;
        import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
        import org.springframework.security.core.context.SecurityContextHolder;
        import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
        import org.springframework.stereotype.Component;
        import org.springframework.web.filter.OncePerRequestFilter;

        import java.io.IOException;
        import java.util.Collections;

        @Component
        public class JwtAuthenticationFilter extends OncePerRequestFilter {
            private final JwtUtil jwtUtil;

            public JwtAuthenticationFilter(JwtUtil jwtUtil) {
                this.jwtUtil = jwtUtil;
            }
            @Override
            protected void doFilterInternal(HttpServletRequest request,
                                            HttpServletResponse response,
                                            FilterChain filterChain) throws ServletException, IOException {
                String authHeader = request.getHeader("Authorization");

                if(authHeader != null && authHeader.startsWith("Bearer")) {
                    String token = authHeader.substring(7);
                    Claims claims = jwtUtil.validateToken(token);
                    if(claims != null) {
                        String username = claims.getSubject();
                        UsernamePasswordAuthenticationToken authentication =
                                new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
                        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(authentication);
                    }
                }
                filterChain.doFilter(request, response);
            }
        }
    //filterChain.doFilter(request, response);
    //서블릿과 콘트롤러 사이를 가로쳐서 실행하는것이 filterchain인데 
    //doFilter 하면 다음 필터체인으로 넘어가는데 현재는 1개 이므로 바로 콘트롤러로 넘어간다.
    //필터체인실행후 콘트롤러로 요청을 다시 돌려준다.



* JwtUtil.java(토큰 검증 메서드 추가)

      package com.example.project.global.security.util;

      import io.jsonwebtoken.Claims;
      import io.jsonwebtoken.Jwts;
      import io.jsonwebtoken.SignatureAlgorithm;
      import org.springframework.stereotype.Component;

      import java.util.Date;

      @Component
      public class JwtUtil{
          private final String secretKey = "mysecretkey93h4klajdflasdhfj3lahsdf3jfaklsdhfakjhjfhaksdjfhaskdf";
          private final long expiration = 1000 * 60 * 60; // 1시간

          public String generateToken(String username){
              return Jwts.builder().setSubject(username)
                      .setIssuedAt(new Date())
                      .setExpiration(new Date(System.currentTimeMillis()+expiration))
                      .signWith(SignatureAlgorithm.HS256, secretKey)
                      .compact();
          }

          public Claims validateToken(String token) {
              try {
                  return Jwts.parser()
                          .setSigningKey(secretKey)
                          .parseClaimsJws(token)
                          .getBody();
              } catch (Exception e) {
                  return null;
              }
          }

      }

* SecurityConfig.java

      package com.example.project.global.security.config;

      import com.example.project.global.security.JwtAuthenticationFilter;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotation.Configuration;
      import org.springframework.security.config.annotation.web.builders.HttpSecurity;
      import org.springframework.security.web.SecurityFilterChain;

      @Configuration
      public class SecurityConfig{

          private final JwtAuthenticationFilter jwtAuthenticationFilter;

          public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
              this.jwtAuthenticationFilter = jwtAuthenticationFilter;
          }

          @Bean
          public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
              http    .csrf(csrf -> csrf.disable())
                      .authorizeHttpRequests((auth) ->auth
                              .requestMatchers("/auth/**", "/").permitAll()
                              .anyRequest().authenticated()
                      )
                      .formLogin(login -> login.disable());

              return http.build();
          }
      }


## Day 6 과제
1. /posts 요청에 JWT 인증 필터를 적용한 뒤, 토큰이 없을 경우 403 Forbidden 응답이 발생하는지 확인하세요.

2. Talend에서 로그인으로 받은 Jwt 토큰을 Authorization헤더에 넣고 /posts 요청을 시도하세요
Authorization : Bearer {발급된 토큰}

3. 잘못된 토큰이나 만료된 토큰을 요청시 어떤 오류 메시지가 나오는지 확인하고 캡처하세요.

4. SecurityContextHolder에 저장된 사용자가 실제로 콘트롤러에서 조회 가능한지 로그를 확인하세요


SecurityConfig.java – 필터 등록 및 보호 경로 설정
@Configuration
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests()
            .requestMatchers("/auth/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
}
* PostController.java – 인증 필요 API

@RestController
@RequestMapping("/posts")
public class PostController {

    @GetMapping
    public ResponseEntity<String> getPosts() {
        String username = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        System.out.println("현재 로그인한 사용자: " + username);
        return ResponseEntity.ok("게시글 목록 (로그인 사용자: " + username + ")");
    }
}


## Day 6 실습형 과제 (1~10번)

[과제 1]
JwtUtil 클래스에 validateToken(String token) 메서드를 작성하세요.
요구 사항:
- 유효한 토큰이면 Claims 객체 반환
- 예외 발생 시 null 반환


        // JwtUtil.java
        public Claims validateToken(String token) {
            try {
                return Jwts.parser()
                        .setSigningKey(secretKey)
                        .parseClaimsJws(token)
                        .getBody();
            } catch (Exception e) {
                return null;
            }
        }

        ✔️ 유효한 JWT라면 Claims를 반환하고, 그렇지 않으면 null 반환.
        secretKey는 generateToken()에서 사용한 동일한 키여야 합니다.


[과제 2]
OncePerRequestFilter를 상속받아 JwtAuthenticationFilter 클래스를 생성하고,
Authorization 헤더에 "Bearer " 토큰이 있을 경우 검증하도록 doFilterInternal 메서드를 구현하세요.


      // JwtAuthenticationFilter.java
      @Component
      public class JwtAuthenticationFilter extends OncePerRequestFilter {

          private final JwtUtil jwtUtil;

          public JwtAuthenticationFilter(JwtUtil jwtUtil) {
              this.jwtUtil = jwtUtil;
          }

          @Override
          protected void doFilterInternal(HttpServletRequest request,
                                          HttpServletResponse response,
                                          FilterChain filterChain)
                  throws ServletException, IOException {

              String authHeader = request.getHeader("Authorization");

              if (authHeader != null && authHeader.startsWith("Bearer ")) {
                  String token = authHeader.substring(7);
                  Claims claims = jwtUtil.validateToken(token);
                  // 다음 과제에서 처리
              }

              filterChain.doFilter(request, response);
          }
      }



      * 요청
      {
        get
        http://localhost:8080/posts
      }
      *응답
      게시글 목록 (로그인 사용자: anonymousUser)


[과제 3]
JwtAuthenticationFilter에서 유효한 토큰이면 SecurityContextHolder에 인증 객체를 저장하도록 구현하세요.
- 인증 객체는 UsernamePasswordAuthenticationToken 사용


    if (claims != null) {
        String username = claims.getSubject();
        UsernamePasswordAuthenticationToken authentication =
            new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());

        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(authentication);
    }

    ✔️ 인증된 사용자 정보를 Spring Security의 SecurityContext에 저장함.


[과제 4]
SecurityConfig.java에 JwtAuthenticationFilter를 등록하고,
모든 요청에 대해 인증이 필요하도록 설정하세요.
- 단, "/auth/**" 경로는 예외로 허용

    // SecurityConfig.java
    @Configuration
    public class SecurityConfig {

        private final JwtAuthenticationFilter jwtAuthenticationFilter;

        public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
            this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        }

        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http.csrf().disable()
                .authorizeHttpRequests()
                .requestMatchers("/auth/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

            return http.build();
        }
    }

    ✔️ 필터 등록 순서가 중요합니다. UsernamePasswordAuthenticationFilter 이전에 삽입해야 작동합니다.



[과제 5]
PostController.java를 생성하고 "/posts" GET 요청 시 로그인한 사용자의 이름을 반환하는 API를 작성하세요.
- SecurityContextHolder에서 사용자명 추출

      {
        Authorization : Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhYWFhQG5hdmVyLmNvbSIsImlhdCI6MTc1NDM2NjQ5MiwiZXhwIjoxNzU0MzcwMDkyfQ.RIvZcCMt5N9BIzd4XYxdsOK5TP8UTcvFGblfGBN9wDc
      }
      String username = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();


      // PostController.java
      @RestController
      @RequestMapping("/posts")
      public class PostController {
          @GetMapping
          public ResponseEntity<String> getPosts() {
              String username = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
              return ResponseEntity.ok("게시글 목록 (로그인 사용자: " + username + ")");
          }
      }
      ✔️ SecurityContextHolder에서 현재 인증된 사용자를 조회하여 반환.



[과제 6]
Talend API Tester를 사용하여 JWT 없이 "/posts" 요청을 보내고,
403 Forbidden 응답이 발생하는지 확인하세요.

    테스트 방법:
    URL: GET http://localhost:8080/posts

    Header 없음
    예상 결과:
    Status: 403 Forbidden
    메시지: Spring Security 인증 실패 메시지


[과제 7]
Talend API Tester를 사용하여 정상 로그인으로 JWT 토큰을 발급받고,
Authorization 헤더에 포함하여 "/posts" 요청을 보내 응답을 확인하세요.


    테스트 방법:
    /auth/login으로 JWT 발급 받기

    Header 추가:
    Authorization: Bearer {발급된 토큰}

    예상 결과:
    Status: 200 OK

    Body: "게시글 목록 (로그인 사용자: user)"


[과제 8]
Talend API Tester로 잘못된 또는 변조된 토큰을 Authorization 헤더에 넣어 "/posts" 요청을 보냈을 때 403 Forbidden이 반환되는지 확인하세요.


    테스트 방법:
    Header: Authorization: Bearer fake.token.value

    예상 결과:
    Status: 403 Forbidden

    로그에 예외 메시지 출력 또는 필터 통과 실패


[과제 9]
JwtAuthenticationFilter 내에서 Claims에서 username을 가져올 수 없는 경우 SecurityContextHolder에 인증 정보를 설정하지 않도록 구현하세요.

    if (claims != null) {
        String username = claims.getSubject();

        if (username != null) {
            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
    }

    ✔️ username이 null이면 인증 객체 생성하지 않음 → 보안 강화


[과제 10]
PostController에서 요청이 들어올 때마다 현재 로그인된 사용자의 이름을 System.out.println으로 로그에 출력되도록 확인하고,
정상적으로 출력되는지 테스트하세요.


    @GetMapping
    public ResponseEntity<String> getPosts() {
        String username = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        System.out.println("현재 로그인한 사용자: " + username);
        return ResponseEntity.ok("게시글 목록 (로그인 사용자: " + username + ")");
    }

    ✔️ 콘솔 출력 확인: 로그인한 사용자 이름이 서버 로그에 출력되는지 Talend 테스트로 검증