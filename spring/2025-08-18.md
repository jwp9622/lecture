# Day 8 - API  응답 표준화 및 예외 처리 통합(Java + Spring Boot  기준)   
* 오늘의 목표   
API 응답을 일관된 포맷으로 제공하기      
예외 발생시 동일한 구조로 오류 응답 처리하기     
     
* 강의 내용      
ApiResponse<T> 표준 응답 객체 설계      
성공/실패 응답 구조 분리   
전역 예외 처리 통합(@ControllerAdvice 활용)      
   
* 응답 구조가 왜 중요한가?   
클라이언트가 응답 구졸르 예측 가능하게 만들어야 함   
예외 상황에서도 구조는 동일해야 함   
예 : data, message, status 포함   
   

* 표준 응답 객체 설계(ApiResponse)   
--> 응답 객체 클래스를 설계하고 제네릭 구조로 만들기   
   
		public class ApiResponse<T>{
			private int status;
			private String message;
			private T data;

			public ApiResponse(int status, String message, T data){
				this.status = status;
				this.emssage = message;
				this.data = data;
			}
		}

* 콘트롤러 응답 구조 변경   
--> 기존 API에서 ApiResponse롤 응답 변경   

		@GetMappig("/{id}")
		public ResponseEntity<ApiResponse<Post>> findOne(@PathVariable Long id){
			Post post = postRepoistory.findById(id).orElseThrow();
			ApiREsponse<Post> response = new ApiResponse<>(200, "조회성공", post);
			return ResponseEntity.ok(response);

		}

* 공통 응답 생성 유틸 만들기   
--> ApiResponse 생성 메서드를 유틸 클래스에 분리   

		public classApiUtils{
			public static<T> AiResponse<T> success(T data){
				return new ApiREsponse<>(200, "성공", data);
			}

			public static<T> AiResponse<T> error(int status, String message){
				return new ApiResponse<>(status, message, null);
			}
		}

* 전역 예외 처리기에서 구조화된 응답 제공   
--> 예외 발생 시도 ApiResponse로 응답 구조 통일   

		public ResponseEntity<ApiResponse<Object>> handleValidationError(MethodArgumentotValidException ex){
			String erroeMessage = ex.getBindingResult().getFiledErrors()
			.stream()
			.map(e->e.getField() + " : "+e.getDefaultMessage()
			.collect(Collectors.joining(", "));

			return ResponseEntity.badRequest().body(apiUtils.error(400, errorMessage));
		}


* 게시글 API에 응답 구조 적용하기   
--> 기존 게시글 API에 표준 응답 구조 적용   
등록, 조회 , 수정 API 모두 ApiResponse로 반환   
예외 상황은 전역 핸들에서 구조화 처리      


* 사용자 정의 예외 처리 추가      

    --> 커스텀 예외를 만들어 특정 상황에 의미 있는 응답 제공   

		public class ResourceNotFoundException extends RuntimeException {
			public ResourceNotFoundException(String msg) {
				super(msg);
			}
		}

    
		    public ResponseEntity<ApiResponse<Object>>
			handleNotFound(ResourceNotFoundException ex) {
				return ResponseEntity.status(404).body(ApiUtils.error(404, ex.getMessage()));
			
		   }


* 실무 예시 응답 구조 예제   
--> 실제 응답 JSON 예시를 제시   

		{
			"status":200,
			"message":"조회 성공",
			"data":{
				"id":1,
				"title": "첫 글입니다",
				"content":""내용입니다"
			}
		}

* 마무리 및 과제   
--> 강의 정리 및 실습 과제   
ApiResponse 도입   
예외 처리 구조 일원화   
ApiUtils 로 응답 간소화   
게시글 API 전체에 ApiResponse 적용   
유효성 검증, NotFound 예외에 구조화된 응답 구현   
   
   
* 과제   
게시글 API ApiREsponse 적용   
유효성 검증, NotFound 예외에 구조화된 응답 구현   
   
   
## 실전 프로젝트 정리 및 보완/배포   
* 강의 개요   
실습 프로젝트 최종 정리   
API 보안의 기초 이해(JWT  소개)   
로컬 실행에서 운영 배포로의 기본 개념 도입   
   
   
* 강의 내용   
프로젝트 통합 점검 치 구조 리뷰   
간단한 인증 구조 및 설계 이해   
REST API 배포 기본 개념과 흐름 이해   
   
* 프로젝트 아키텍처 복습   
우리가 구축한 전체 API 구조 점검   
--> 우리가 구축한 전체 API 구조 점검   
계층 구조 : Controller -> Service -> Repository -> Entity   
공통 응답 포맷 적용   
전역 예외 처리기 구성   
   
* 실전 기능 통합 테스트   
--> 전체 API 흐름을 통합적으로 실행해보기   
   
   
* 강의 내용   
POST /posts - 게시글 등록   
GET /posts - 전체 조회   
PUT /posts {id} - 수정   
DELETE /posts/{id} - 삭제   
   
* API 인증이 필요한 이유   
--> 인증/인가 개념의 필요성 소개   
      
인증(Authentication) : 누구인지 확인   
인가(Authorization) :  권한을 확인   
실전에서는 토큰(JWT)을 사용해서 인증 수행   
   
* JWT(Json Web Token) 기존 구조   
--> JWT의 동작 방식 개요   
   
구조 : Header + Payload + Signature   
클라이언트는 JWT를 발급받고, 이후 요청 헤더에 토큰을 담아 인증   
   
* 간단한 보안 적용 예시(시뮬레이션)   
--> 토큰을 요구하는 API 구조를 예시로 소개   

		@GetMapping("/secure/posts")
		public ResponseEntity<?> securePosts(@RequestHeader("Authorization") String token){
			if(!token.equals("earer my-token"){
				return ResponseEntity.status(401).body("인증되지 않음");
			}
			return ResponseEntity.ok("인증된 게시글 조회");
		}
--> Authorization : Bearer my-token


* 배포란 무엇인가?   
--> 로컬에서 만든 API를 외부에서 접근할 수 있게 하는 과정   
   
배포(Depolyent) = 서버에 코드 실행 환경 구축   
Jar 실행, 클라우드 서비스(AWS, GCP, Heroku 등)   
포트 개방, DB 연결, 보안 설정 등 필요   
   
   
* 간단한 배포 흐름 예시   
로컬 -> JAR 빌드 -> 서버 실행 흐름   

		./mvnw  clean package

		java -jar target/demo-0.0.1-SNAPSHOT.jar

* 마무리   
--> 전체 정리 및 다음 단계   
REST 개념 --> Spring Boot --> JPA --> 예외처리 --> Talend API Tester --> 보안   
Spring Security JWT 실전 적용   
MySql등 외부 DB  연동   
CI/CD Docker 등 배포 자동화   
   

##  RESTful API 작업형 10문제
   
1. HelloController 생성   
 Spring Boot에서 /hello로 요청이 오면 "Hello, Spring Boot!"를 문자열로 응답하는 API를 작성하시오.   
   
   
2. 사용자 ID 조회 API 만들기   
 GET /users/{id} 요청이 들어오면 "User ID: {id}" 형태의 문자열을 반환하는 API를 구현하시오.   
   
   
3. 사용자 등록 API 만들기   
 JSON 형식으로 name과 email을 받아 "Created user: 홍길동" 형태로 응답하는 API를 구현하시오.   
   
   
4. @RequestParam 기반 인사 API 구현   
 GET /users/hello?name=홍길동 요청 시 "안녕하세요, 홍길동님"을 반환하는 API를 작성하시오.   
   
   
5. Talend API Tester로 POST 요청 테스트 JSON 만들기   
 POST 요청으로 사용자 이름 "kim"과 이메일 "kim@example.com"을 보내기 위한 JSON Body를 작성하시오.   
   
   
6. UserDto에 Lombok 적용   
 UserDto 클래스에 Lombok을 적용하여 getter, setter 없이 같은 기능을 하도록 수정하시오.   
   
   
7. GET 요청 테스트 URL 만들기   
 사용자 ID가 7일 때 해당 사용자를 조회하는 GET 요청 URL을 작성하시오.   
   
   
8. JSON 응답 형태로 사용자 등록 결과 반환   
 POST 요청 후 등록된 사용자 정보를 JSON 형식으로 반환하도록 코드를 수정하시오.   
      

9. 기본 상태 코드 확인용 API 만들기      
 /status 경로로 GET 요청 시 204 No Content 상태코드를 반환하는 API를 구현하시오.   
   
   
10.사용자 목록 반환 API 구현   
 3명의 사용자 정보를 가진 리스트를 /users/all 경로에서 JSON 배열로 반환하는 API를 작성하시오.   
   
   
## RESTful API 작업형 10문제 풀이
      
1) HelloController 생성 – /hello → "Hello, Spring Boot!"   
   
		@RestController
		public class HelloController {
		    @GetMapping("/hello")
		    public String hello() {
			return "Hello, Spring Boot!";
		    }
		}


2) 사용자 ID 조회 API – GET /users/{id} → "User ID: {id}"   

		@RestController
		@RequestMapping("/users")
		public class UserController {

		    @GetMapping("/{id}")
		    public String getUserById(@PathVariable Long id) {
			return "User ID: " + id;
		    }
		}


3) 사용자 등록 API – JSON(name, email) 받아 "Created user: 홍길동"   

		@Data // Lombok(문제6과도 연계)
		@AllArgsConstructor @NoArgsConstructor
		class UserDto {
		    private String name;
		    private String email;
		}


		@PostMapping
		public String createUser(@RequestBody UserDto dto) {
		    return "Created user: " + dto.getName();
		}


4) @RequestParam 기반 인사 API – GET /users/hello?name=홍길동   

		@GetMapping("/hello")
		public String helloUser(@RequestParam String name) {
		    return "안녕하세요, " + name + "님";
		}


5) Talend API Tester용 POST JSON Body   

		{
		  "name": "kim",
		  "email": "kim@example.com"
		}


6) UserDto에 Lombok 적용 (getter/setter 없이 동일 기능)   


		import lombok.*;

		@Data
		@AllArgsConstructor
		@NoArgsConstructor
		class UserDto {
		    private String name;
		    private String email;
		}


@Data가 getter/setter/toString/equals/hashCode 생성, 생성자는 @AllArgsConstructor, @NoArgsConstructor.   
   
7) GET 요청 테스트 URL (사용자 ID=7)   
GET http://localhost:8080/users/7



8) JSON 응답 형태로 사용자 등록 결과 반환 (POST 후 UserDto 반환)   

		@PostMapping("/json")
		public ResponseEntity<UserDto> createUserJson(@RequestBody UserDto dto) {
		    // 실제라면 저장 로직 수행 후 저장된 엔티티/DTO 반환
		    return ResponseEntity.status(HttpStatus.CREATED).body(dto);
		}

예상 응답:   

		{
		  "name": "홍길동",
		  "email": "hong@example.com"
		}

9) 기본 상태 코드 확인용 API – GET /status → 204 No Content   

		@GetMapping("/status")
		public ResponseEntity<Void> status() {
		    return ResponseEntity.noContent().build(); // 204
		}


10) 사용자 목록 반환 API – GET /users/all → JSON 배열   

		@GetMapping("/all")
		public List<UserDto> getAllUsers() {
		    return List.of(
			new UserDto("kim", "kim@example.com"),
			new UserDto("lee", "lee@example.com"),
			new UserDto("park", "park@example.com")
		    );
		}


예상 응답:   

		[
		  {"name":"kim","email":"kim@example.com"},
		  {"name":"lee","email":"lee@example.com"},
		  {"name":"park","email":"park@example.com"}
		]


참고: 컨트롤러 전체 예시 (합본)   

		import lombok.*;
		import org.springframework.http.*;
		import org.springframework.web.bind.annotation.*;
		import java.util.List;

		@RestController
		class HelloController {
		    @GetMapping("/hello")
		    public String hello() { return "Hello, Spring Boot!"; }
		}


		@Data @AllArgsConstructor @NoArgsConstructor
		class UserDto { 
			private String name; 
			private String email; 
		}



		@RestController
		@RequestMapping("/users")
		class UserController {

		    @GetMapping("/{id}")
		    public String getUserById(@PathVariable Long id) {
			return "User ID: " + id;
		    }

		    @PostMapping
		    public String createUser(@RequestBody UserDto dto) {
			return "Created user: " + dto.getName();
		    }

		    @GetMapping("/hello")
		    public String helloUser(@RequestParam String name) {
			return "안녕하세요, " + name + "님";
		    }

		    @PostMapping("/json")
		    public ResponseEntity<UserDto> createUserJson(@RequestBody UserDto dto) {
			return ResponseEntity.status(HttpStatus.CREATED).body(dto);
		    }

		    @GetMapping("/status")
		    public ResponseEntity<Void> status() {
			return ResponseEntity.noContent().build();
		    }

		}


		@GetMapping("/all")
		    public List<UserDto> getAllUsers() {
			return List.of(
			    new UserDto("kim","kim@example.com"),
			    new UserDto("lee","lee@example.com"),
			    new UserDto("park","park@example.com")
			);
		    }
		}