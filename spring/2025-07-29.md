#
## 웹 구조와 아키텍처 리뷰
간단하고 반듯하게 되어있는것이 스프링부트이다.   
MVC  패턴, 계층 역할 솔루션 모델   

* 웹 애플리케이션의 기본 구조 + 동작 흐름   
  클라이언트 - 서버 모델  =. 핵심은 웹(비연결지향 프로토콜)   
  요청/응답 사이클 이해(HTTP)   
   

* MVC 패턴 + 계층별 역할   
   
	Controller, Service, Repository  역할   
	View 필요성 + API 기반 서비스 대체    
   
* RESTful 설계 기본 원리   
	Resource 기반 URI 설계   
	Stateless 구조
   
   
* 솔루션 9단계   
  1. 클라이언트 호출   
  2. 서비스호출   
  3. 서비스 엔티티   
  4. 엔티티 DB      
  5. 리턴   
  6. 리턴   
  7. 리턴   
  8. 콘트롤러 뷰 선택   
  9. 응답 클라이언트 보내기   
   
* 스프링 부트 계층 구조   
1. 도메인(엔티티, dto)   
2. 리포지토리   
3. 서비스   
4. 콘트롤러   
5. 뷰   
   
* 콘트롤러 6가지 기능   
값추출, 값 검증, 값변환, 서비스호출, 뷰선택, 예외처리   
--> POJO(Plain Old Java Object)   
   
## 실습 주제   
간단한 HelloController  생성 --> hello 요청 응답 구현   
Controller --> Service --> Respository 흐름 따라가기   
Talend 테스트 --> 요청, 응답 확인   
   
* 실무 기준 프로젝트 구조   
   
- 메인 클래스(HelloAppapplication.java)   
- 콘트롤러(HelloController.java)   
- 서비스(HelloServie.java)   
- 리포지토리(HelloRepository.java)   
   
   
* 메인 클래스 (HelloAppApplication.java)   
				
			package com.example.helloapp;   

			import org.springframework.boot.SpringApplication;
			import org.springframework.boot.autoconfigure.SpringBootApplication;

			@SpringBootApplication
			public class HelloAppApplication {
					public static void main(String[] args) {
				SpringApplication.run(HelloAppApplication.class, args);
					}
			}

* 컨트롤러 (HelloController.java)
			
			package com.example.helloapp.controller;

			import com.example.helloapp.service.HelloService;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.RestController;

			@RestController
			public class HelloController {
					private final HelloService helloService;

					public HelloController(HelloService helloService) {
				this.helloService = helloService;
					}

					@GetMapping("/hello")
					public String hello() {
				return helloService.getHelloMessage();
					}
			}

* 서비스 (HelloService.java)
			
			package com.example.helloapp.service;

			import org.springframework.stereotype.Service;

			@Service
			public class HelloService {
					public String getHelloMessage() {
				return "Hello, Web Developer!";
					}
			}

* 레포지토리 (HelloRepository.java)

			package com.example.helloapp.repository;

			import org.springframework.stereotype.Repository;

			@Repository
			public class HelloRepository {
					public String fetchGreeting() {
				return "Hello from Repository!";
					}
			}

## Day 1  과제
1. 위 실습 과제를 본인 로컬 프로젝트에서 직접 구현해보세요(패키지 구조 동일하게 유지)
📂 기본 패키지 구조

		com.example.helloapp
		├── HelloAppApplication.java
		├── controller
		│   └── HelloController.java
		├── service
		│   └── HelloService.java
		├── repository
		│   └── HelloRepository.java


2. /hello 외에 본인이 만든 임의의 URI /greet를 추가로 만들어보고, 응답 문자열을 변경해보세요

			* HelloAppApplication.java
			Spring Boot 애플리케이션의 진입점입니다.

			package com.example.helloapp;

			import org.springframework.boot.SpringApplication;
			import org.springframework.boot.autoconfigure.SpringBootApplication;

			@SpringBootApplication
			public class HelloAppApplication {
					public static void main(String[] args) {
				SpringApplication.run(HelloAppApplication.class, args);
					}
			}

3. HelloService에서 날짜/시간 또는 이름을 포함한 동적 응답 메시지를 만들어보세요.

			* HelloController.java
				--> /hello와 /greet 두 URI를 처리합니다.
				
			package com.example.helloapp.controller;

			import com.example.helloapp.service.HelloService;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.RestController;

			@RestController
			public class HelloController {

					private final HelloService helloService;

					public HelloController(HelloService helloService) {
				this.helloService = helloService;
					}

					@GetMapping("/hello")
					public String hello() {
				return helloService.getHelloMessage();
					}

					@GetMapping("/greet")
					public String greet() {
				return helloService.getGreetingMessage();
					}
			}

4. Postman 또는 curl을 활용하여 /hello, /greet 호출 결괄르 캡처해서 호출하세요.
	/greet 요청 결과를 확인하고 응답 캡처 화면을 저장하세요.

			* HelloService.java
				--> Service 계층에서 동적 메시지를 생성합니다 (현재 시간 포함)
				
			package com.example.helloapp.service;

			import com.example.helloapp.repository.HelloRepository;
			import org.springframework.stereotype.Service;

			import java.time.LocalDateTime;

			@Service
			public class HelloService {

					private final HelloRepository helloRepository;

					public HelloService(HelloRepository helloRepository) {
				this.helloRepository = helloRepository;
					}

					public String getHelloMessage() {
				return "Hello, Web Developer!";
					}

					public String getGreetingMessage() {
				String base = helloRepository.fetchGreeting();
				String now = LocalDateTime.now().toString();
				return base + " 현재 시간은: " + now;
					}
			}

5. 선택 : HelloRepository를 활용해 Service에서 데이터를 주입받아보세요(의존성 주입 실습)
	* HelloRepository.java (선택 사항)
	  --> package com.example.helloapp.repository;

			import org.springframework.stereotype.Repository;

			@Repository
			public class HelloRepository {
					public String fetchGreeting() {
				return "안녕하세요! 이것은 Repository에서 가져온 인사입니다.";
					}
			}



## 검증과 예외 처리

## 문제 1

`UserDto` 클래스에 다음 조건을 만족하는 필드를 선언하고, 알맞은 검증 어노테이션을 붙이세요.

* 이름(name): 2\~20자, 공백 불가
* 이메일(email): 이메일 형식 필수
* 나이(age): null 불가, 18세 이상


		// UserDto.java
		public class UserDto {

		    @NotBlank(message = "이름은 공백일 수 없습니다.")
		    @Size(min = 2, max = 20, message = "이름은 2자 이상 20자 이하로 입력하세요.")
		    private String name;

		    @Email(message = "올바른 이메일 형식을 입력하세요.")
		    private String email;

		    @NotNull(message = "나이는 필수 항목입니다.")
		    @Min(value = 18, message = "18세 이상만 등록 가능합니다.")
		    private Integer age;

		    // getters, setters
		}




## 문제 2

작성한 `UserDto`에 대해 POST 요청을 처리하는 `UserController`의 `/users` API를 만들고,
`@Valid`를 적용해 유효성 검증을 수행하세요.
예외 발생 시 기본적으로 400 오류가 발생해야 합니다.


		// UserController.java
		@RestController
		@RequestMapping("/users")
		public class UserController {

		    @PostMapping
		    public ResponseEntity<String> createUser(@RequestBody @Valid UserDto userDto) {
			// 저장 로직 생략
			return ResponseEntity.ok("사용자 등록 완료");
		    }
		}

## 문제 3

`UserDto`에서 이름(name) 필드가 유효하지 않을 경우,
“이름은 2자 이상이어야 합니다”라는 메시지를 커스터마이징해 출력되도록 설정하세요.


		@NotBlank(message = "이름은 공백일 수 없습니다.")
		@Size(min = 2, message = "이름은 2자 이상이어야 합니다.")




## 문제 4

유효하지 않은 요청이 들어왔을 때   
필드별로 `"필드명": "에러 메시지"` 형태의 JSON 응답이 내려가도록   
`GlobalExceptionHandler`를 작성하세요.   
힌트: `MethodArgumentNotValidException` 처리   


		// GlobalExceptionHandler.java
		@ExceptionHandler(MethodArgumentNotValidException.class)
		public ResponseEntity<Map<String, String>> handleValidationErrors(MethodArgumentNotValidException ex) {
		    Map<String, String> errors = new HashMap<>();
		    ex.getBindingResult().getFieldErrors().forEach(error ->
			errors.put(error.getField(), error.getDefaultMessage()));
		    return ResponseEntity.badRequest().body(errors);
		}

## 문제 5

`UserController`에서 `/users/{id}` 요청이 들어왔을 때   
존재하지 않는 사용자라면 `NotFoundException`을 발생시키고,   
404 에러와 함께 `"사용자를 찾을 수 없습니다"` 메시지를 출력하세요.   

		@GetMapping("/{id}")
		public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
		    UserDto user = userService.findById(id)
			.orElseThrow(() -> new NotFoundException("사용자를 찾을 수 없습니다"));
		    return ResponseEntity.ok(user);
		}



## 문제 6

`NotFoundException` 클래스와 이를 처리하는   
`@ExceptionHandler` 메서드를 `GlobalExceptionHandler`에 추가하세요.   

		// NotFoundException.java
		public class NotFoundException extends RuntimeException {
		    public NotFoundException(String message) {
			super(message);
		    }
		}

		// GlobalExceptionHandler.java
		@ExceptionHandler(NotFoundException.class)
		public ResponseEntity<Map<String, String>> handleNotFound(NotFoundException ex) {
		    Map<String, String> error = new HashMap<>();
		    error.put("message", ex.getMessage());
		    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
		}




## 문제 7

다음과 같은 상황에서 유효성 검증을 통과하지 못하도록 `UserDto`를 수정하세요.   

* 이메일 형식이 잘못됨   
* 나이가 null   
* 이름이 공백 문자열(" ")   

각 필드에 어노테이션을 정확히 적용하세요.   

		@Email(message = "이메일 형식이 아닙니다.")
		@NotNull(message = "나이는 필수입니다.")
		@NotBlank(message = "이름은 공백일 수 없습니다.")



## 문제 8

Talend API Tester로
유효하지 않은 JSON 요청을 전송하고,
클라이언트가 어떤 응답을 받는지 확인 후 응답 결과를 복사해보세요.
(예: 필드 누락, 잘못된 형식 등)

		json
		// 요청 JSON (문제 있는 입력)
		{
		  "name": "",
		  "email": "not-an-email",
		  "age": null
		}

		// 응답 JSON
		{
		  "name": "이름은 공백일 수 없습니다.",
		  "email": "이메일 형식이 아닙니다.",
		  "age": "나이는 필수입니다."
		}




## 문제 9

유효성 실패 시 다음과 같은 형태의 JSON 응답이 내려가도록 하세요:

		json
		{
		  "name": "이름은 2자 이상이어야 합니다",
		  "email": "이메일 형식이 아닙니다"
		}


		json
		{
		  "name": "이름은 2자 이상이어야 합니다",
		  "email": "이메일 형식이 아닙니다"
		}




## 문제 10

`@Valid`를 사용하지 않고 유효성 검증을 수행했을 때 생길 수 있는 문제점은 무엇인지 코드 예시와 함께 설명하세요.
그리고 왜 `@Valid`를 사용하는 것이 더 바람직한지 기술하세요.


		// 잘못된 예 (유효성 검증 누락)
		@PostMapping
		public ResponseEntity<String> create(@RequestBody UserDto dto) {
		    // 검증 로직 없음 → 잘못된 데이터가 저장될 수 있음
		    return ResponseEntity.ok("등록됨");
		}

		// 권장 방식
		@PostMapping
		public ResponseEntity<String> create(@RequestBody @Valid UserDto dto) {
		    return ResponseEntity.ok("등록됨");
		}

		// 이유: @Valid는 스프링이 자동으로 유효성 검사 수행 및 예외 발생시켜줌.
		// 코드가 간결하고 신뢰성이 높아짐
