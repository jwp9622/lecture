#
## Day 8 : 페이징 & 검색 조건 API 실습(Talend 기반)
* 강의 목표   
 pageable, Sort, @RequestParam을 이용한 페이징 처리 구현   
 제목 키워드 검색 기능 API 개발   
 Talend API Tester를 통한 페이지/검색 조거 테스트 수행   
   
* 강의 내용
1. Spring Data JPA 에서 Pageable, Page<T> 구조 이해
2. @RequestParam을 통한 page, size, keyword 파라미터 처리
3. 검색 조건이 포함된 게시글 목록 API 개발
4. Talend를 활용한 페이지 이동, 키워드 검색 테스트

* 실습 코드 : 게시글 목록 페이징 + 검색 API
* Post.java
package com.example.board.dmain;
import jakarata.persistence.*;
@Entity
@Getter
@Setter
public class Post {
  @Id
  @GeneratedValue(stragety=GenerationType.IDENTITY)
  private Long id;

  private String title;
  
  private String content;

}

* PostRepository.java

  package com.example.board.repository;
  import com.example.board.domain.Post;
  import org.springframework.data.domain.Page;
  import org.springframework.data.domain.Pageable;
  import org.springframework.data.jpa.repository.JpaRepository;

  public interface PostRepository estends JpaRepository<Post, Long>{
    Page<Post> findByTitleContaining(String keyword, Pageable pageable);

  }

* PostController.java(목록 조회 API 추가)
@GetMapping
public ResponseEntity<Page<Post>> getPosts(
  @RequestParam(defaultValue="")String keyword
  @RequestParam(defaultValue="0") int paage,
  @RequestParam(defaultValue="5") int size
){
  Pageable pageable = PageRequest.of(page.size, Sort.by("id").decending());
  Page<Post> posts = PostRepository.findByTitleContaining(keyword, pageable);
  return ResponseEntity.ok(posts);
}

## Day8 과제
1. 게시글 10건 이상 생성 후 / posts API에서 page, size 값을 변경해 Talend로 조회해 보세요.

2. keyword 파라미터에 일부 제목 키워드를 넣고 결과가 필터링 되는지 확인하세요.

3. 응답의 totalpages, totalElements, content구조를 캡처하고 분석해보세요.

4. 정렬 기준을 title 기준으로 바꾸고 정렬 순서를 조작하려면 어떻게 개선할 수 있을지 실습하세요.



📂 패키지 구조
com.example.board
├── BoardApplication.java
├── domain
│   └── Post.java
├── repository
│   └── PostRepository.java
├── controller
│   └── PostController.java



* Post 엔티티

        // domain/Post.java
        package com.example.board.domain;

        import jakarta.persistence.*;

        @Entity
        public class Post {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            private String title;
            private String content;

            // Getters & Setters
        }

* PostRepository

        // repository/PostRepository.java
        package com.example.board.repository;
        import com.example.board.domain.Post;
        import org.springframework.data.domain.*;
        import org.springframework.data.jpa.repository.JpaRepository;
        public interface PostRepository extends JpaRepository<Post, Long> {
            Page<Post> findByTitleContaining(String keyword, Pageable pageable);
        }

* PostController – 페이징 & 검색 API

        // controller/PostController.java
        package com.example.board.controller;

        import com.example.board.domain.Post;
        import com.example.board.repository.PostRepository;
        import org.springframework.data.domain.*;
        import org.springframework.http.ResponseEntity;
        import org.springframework.web.bind.annotation.*;

        @RestController
        @RequestMapping("/posts")
        public class PostController {

            private final PostRepository postRepository;

            public PostController(PostRepository postRepository) {
                this.postRepository = postRepository;
            }
            @GetMapping
            public ResponseEntity<Page<Post>> getPosts(
                    @RequestParam(defaultValue = "") String keyword,
                    @RequestParam(defaultValue = "0") int page,
                    @RequestParam(defaultValue = "5") int size,
                    @RequestParam(defaultValue = "id") String sort,
                    @RequestParam(defaultValue = "desc") String direction) {

                Sort sortObj = direction.equalsIgnoreCase("asc") ?
                        Sort.by(sort).ascending() : Sort.by(sort).descending();

                Pageable pageable = PageRequest.of(page, size, sortObj);

                Page<Post> result = postRepository.findByTitleContaining(keyword, pageable);
                return ResponseEntity.ok(result);
            }
        }


  * Talend 요청 예시

        * 기본 페이징 테스트

      GET /posts?page=0&size=5

      응답 JSON 구조:

      {
        "content": [...],
        "totalElements": 15,
        "totalPages": 3,
        "number": 0
      }


        * 검색 조건 테스트
      GET /posts?keyword=공지
      --> 제목에 "공지" 포함된 게시글만 필터링됨


        * 정렬 기준 바꾸기
      GET /posts?sort=title&direction=asc
      --> 제목 오름차순 정렬 확인


        * 정렬 기준 개선 예시
      @RequestParam(defaultValue = "id") String sort,
      @RequestParam(defaultValue = "desc") String direction

      이 방식으로 title, content, id 등 유연하게 정렬 가능
      PageRequest.of(page, size, Sort.by(...))로 적용

** 참고사항
@RequestParam의 defaultValue는 항상 String 타입입니다.
파라미터 타입이 int, boolean, double이라도 String으로 전달된 값을 내부적으로 자동 변환(conversion) 합니다.



## Day 8 실습형 과제 10문제

문제 1
Post 엔티티를 정의하세요.
id, title, content 필드를 포함하고

@Entity, @Id, @GeneratedValue를 사용하세요.



문제 2
PostRepository 인터페이스를 생성하고,
 제목에 특정 키워드가 포함된 게시글을 페이징 처리로 조회하는 메서드를 정의하세요.
 힌트: findByTitleContaining(String keyword, Pageable pageable)



문제 3
PostController에서 GET 요청으로 게시글 목록을 조회하는 API를 작성하세요.
경로: /posts

QueryParam: page, size, keyword 사용



문제 4
Spring의 PageRequest.of(page, size, Sort.by(...))를 사용해
 id 기준 내림차순으로 정렬하도록 설정하세요.



문제 5
Talend API Tester를 사용해서 다음 요청을 보내고 결과를 확인하세요:
GET /posts?page=0&size=5



문제 6
10건 이상의 게시글을 등록한 뒤,
 /posts?page=1&size=3와 같이 페이지를 이동하며 결과가 바뀌는지 테스트하세요.



문제 7
다음 요청을 보내고, 제목에 포함된 키워드로 필터링이 잘 작동하는지 확인하세요:
GET /posts?keyword=공지



문제 8
API 응답에서 다음 항목이 포함되어 있는지 Talend에서 캡처하고 분석하세요:
totalPages

totalElements

content



문제 9
정렬 기준을 "title"로 바꾸고, 오름차순 정렬이 되도록 API를 수정해보세요.
 (힌트: Sort.by("title").ascending())



문제 10
페이징과 검색 기능이 왜 필요한지, 어떤 상황에서 가장 유용한지에 대해 간단히 설명하세요.
 → 클라이언트 UX, 서버 효율성 관점 포함


## Day 8 실습형 문제 풀이

문제 1
Post.java
package com.example.board.domain;

import jakarta.persistence.*;

@Entity
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String content;

    // Getters, Setters
}
문제 2
PostRepository.java
package com.example.board.repository;

import com.example.board.domain.Post;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PostRepository extends JpaRepository<Post, Long> {
    Page<Post> findByTitleContaining(String keyword, Pageable pageable);
}
문제 3
PostController.java
package com.example.board.controller;

import com.example.board.domain.Post;
import com.example.board.repository.PostRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/posts")
public class PostController {

    private final PostRepository postRepository;

    public PostController(PostRepository postRepository) {
        this.postRepository = postRepository;
    }
@GetMapping
    public ResponseEntity<Page<Post>> getPosts(
            @RequestParam(defaultValue = "") String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "5") int size) {

        Pageable pageable = PageRequest.of(page, size, Sort.by("id").descending());
        Page<Post> posts = postRepository.findByTitleContaining(keyword, pageable);
        return ResponseEntity.ok(posts);
    }
}
문제 4
PageRequest.of(...) 설정
Pageable pageable = PageRequest.of(page, size, Sort.by("id").descending());


문제 5
Talend 테스트 - 기본 페이징
URL: GET http://localhost:8080/posts?page=0&size=5


확인: 첫 번째 페이지 게시글 5건만 응답됨



문제 6
Talend 테스트 - 페이지 이동
요청 1: page=0&size=3


요청 2: page=1&size=3


결과: 게시글 리스트가 페이지에 따라 바뀌는지 확인



문제 7
Talend 테스트 - 키워드 검색
요청: GET /posts?keyword=공지


결과: 제목에 "공지"가 포함된 게시글만 조회



문제 8
Talend 응답 확인
응답 JSON 구조 예시:
{
  "content": [...],
  "totalElements": 12,
  "totalPages": 3,
  "number": 0,
  ...
}

→ totalPages, totalElements, content 존재 여부 확인

문제 9
정렬 기준 변경: title 오름차순
Pageable pageable = PageRequest.of(page, size, Sort.by("title").ascending());

→ 요청 결과에서 제목순으로 정렬된 데이터 확인

문제 10
페이징 & 검색의 장점
서버: 대용량 데이터 조회 시 성능 부담 줄임 (예: 1만건 중 10건만 응답)


클라이언트: 필요한 정보만 받아서 사용자 UX 향상


검색: 사용자 맞춤형 정보 탐색에 유리 (예: 키워드 필터, 조건 검색)

