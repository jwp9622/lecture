# Day5 : JWT 기반 로그인 인증 실습(Talend  기반)  
##   
클라리언트가 토큰을 가지고 로그인  
로그인요청시 jwt 발급됨  
토큰을 헤더에 사용해서 다음에 사용함.  
  
토큰 발급 --> 토큰 검증 --> 인증 성공 -- 리소스 접근 허용  
  
* 강의 목표  
JWT(Json Web Token) 기반 로그인 인증 구조 이해  
Spring Security와 JWT 통합 흐름 구현  
Talend API Tester로 로그인 요청 및 인증 테스트 수행  
  
* 강의 내용  
JWT 구조 및 작동 방식 이해  
Spring Security 설정(비밀번호 암호화, 인증 필터 구성)  
로그인 요청 처리 및 JWT 토큰 발급  
JWT 토큰 기반 사용자 인증 처리 흐름 구현  
  
## 실습 코드 : JWT 인증 흐름 구현  
> 실습 코드: JWT 인증 흐름 구현  
  
  * 구성  
  com.example.jwt  
    |-- JwtApplication.java  
    |-- controller  
      |-- AuthController.java  
    |-- config  
      |-- SecurityConfig.java  
    |-- dto  
      |-- LoginRequest.java  
    |-- util  
        |-- JwtUtil.java  

* LoginRequest.java  

      package com.example.jwt.dto;

      public class LoginRequest {
        private String username;
        private String password;

        public String getUsername() { return username; }
        public void setUsername(String username) { this.username = username; }
        public String getPassword() { return password; }
        public void setPassword(String password) { this.password = password; }
      }

* AuthController.java

    package com.example.jwt.controller;
    
    import com.example.jwt.dto.LoginRequest;
    import com.example.jwt.util.JwtUtil;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;

    @RestController
    @RequestMapping("/auth")
    public class AuthController {
      private final JwtUtil jwtUtil;
      
      public AuthController(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
      }

      @PostMapping("/login")
      public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        if("user".equals(request.getUsername()) && "1234".equals(request.getPassword())) {
          String token = jwtUtil.generateToken(request.getUsername());
          return ResponseEntity.ok().body("Bearer " + token);		
        } else {
          return ResponseEntity.status(401).body("로그인 실패");
        }	
      }

    }



* JwtUril.java

    package com.exmaple.jwt.util;

    import io.jsonwebtoken.Jwts;
    import io.jsonwetoken.SignatureAlgorithm;
    import org.springframework.stereotyp.Component;
    import java.util.Date;

    @Component
    @public class JwtUtil{
      private final String secretKey = "my-secret-key";
      private final long expiration = 1000 * 60 * 60 // 1시간
      
      public String generateToken(String username){
        return Jwts.builder().setSubject(username)
                            .setIssueedAt(new Date())
                            .setExpiration(new Date(System.currentTimeMillis())+expiration)
                            .signWith(SignatureAlgorithm.HS256, secretKey);
                            .compact();

      }
    }

  *SecurityConig.java(JWT 필터 이후 Day에서 확장)
      package com.exmaple.jwt.config;

      import io.jsonwebtoken.Jwts;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotationConfiguration;
      import org.springframework.security.we.SecurityFilterChain;

      @Configuration
      public class SecurityConfig{
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
          http.csrf().disable()
                    .authorizeHttpRequest()
                    .requestMatchers("/auth/**").permitAll()
                    .anyRequest().authenticated();
          return http.build();
        }
      }

# Day5 과제
1. 위 코드를 실행하고 /auth/login에 Talend를 통해 올바른 JSON을 POST 요청해 보세요

        {
          "username":"user"
          "password":"1234"
        }

* JwtApplication.java

        package com.example.jwt;
        improt org.springframework.boot.SpringApplication'
        import. org.springframework.bootautoconfigure.SpringBootApplication;

        @SpringBootApplication
        public class JwtApplication{
          public static void main(String[] args){

          }
        }


2.응답으로 발급된 JWT 토큰을 복사해보세요

* LoginRequest.java
        package com.example.jwt.dto;

        public class LoginRequest {
          private String username;
          private String password;

          public String getUsername() { return username; }
          public void setUsername(String username) { this.username = username; }
          public String getPassword() { return password; }
          public void setPassword(String password) { this.password = password; }
        }



3. 토큰을 복호화 해보고, payload 내용 확인(jwt.io. 또는 로컬 유틸 활용)
* jwtUril.java

        import io.jsonwebtoken.Jwts;
        import io.jsonwetoken.SignatureAlgorithm;
        import org.springframework.stereotyp.Component;
        import java.util.Date;

        @Component
        @public class JwtUtil{
          private final String secretKey = "my-secret-key";
          private final long expiration = 1000 * 60 * 60 // 1시간
          
          public String generateToken(String username){
            return Jwts.builder().setSubject(username)
                                .setIssueedAt(new Date())
                                .setExpiration(new Date(System.currentTimeMillis())+expiration)
                                .signWith(SignatureAlgorithm.HS256, secretKey);
                                .compact();

          }
        }

4. 비정상 로그인 시 401 오류가 발생하는지 확인하고, 메시지를 캡처해 보세요.

        package com.example.jwt.controller;
        
        import com.example.jwt.dto.LoginRequest;
        import com.example.jwt.util.JwtUtil;
        import org.springframework.http.ResponseEntity;
        import org.springframework.web.bind.annotation.*;

        @RestController
        @RequestMapping("/auth")
        public class AuthController {
          private final JwtUtil jwtUtil;
          
          public AuthController(JwtUtil jwtUtil) {
            this.jwtUtil = jwtUtil;
          }

          @PostMapping("/login")
          public ResponseEntity<?> login(@RequestBody LoginRequest request) {
            if("user".equals(request.getUsername()) && "1234".equals(request.getPassword())) {
              String token = jwtUtil.generateToken(request.getUsername());
              return ResponseEntity.ok().body("Bearer " + token);		
            } else {
              return ResponseEntity.status(401).body("로그인 실패");
            }	
          }

        }

* SecurityConfig.java

      package com.exmaple.jwt.config;

      import io.jsonwebtoken.Jwts;
      import org.springframework.context.annotation.Bean;
      import org.springframework.context.annotationConfiguration;
      import org.springframework.security.we.SecurityFilterChain;

      @Configuration
      public class SecurityConfig{
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
          http.csrf().disable()
                    .authorizeHttpRequest()
                    .requestMatchers("/auth/**").permitAll()
                    .anyRequest().authenticated();
          return http.build();
        }
      }

## Talend API Tester 테스트

  1. 테스트 1 - 정상 로그인 요청

     * POST 요청

       URL : http://localhost:8080/auth/login
       Headers : Content-Type: application/json


     * Body

       {
	   "username": "user",
	   "password": "1234"
       }


     * 예상 응답

       Status: 200 OK
       Body: Bearer eyJhbGciOiJIUzL1NilslnR5cCI6lkpXVCJ9....


  2. 테스트 2 - 토큰 복호화 확인

     * 방법 1: https://jwt.io
       
       --> 토큰 붙여넣고 Payload 확인

     
     * 예시 Payload

     {
	"sub": "user",
	"iat": 1727130000,
	"exp": 1727133600
     }
    
 
  3. 테스트 3 - 비정상 로그인 요청

     * Body

     {
	"username": "user",
	"password": "wrong"
     }


     * 예상 응답

     Status: 401 Unauthorized
     Body: 로그인 실패



## Day 5 프로그램 작성형 실습 문제 10문제

* 문제 1  
LoginRequest 클래스를 작성하고, 사용자로부터 username과 password를 JSON 형태로 전달받도록 구성하세요.  
 getter/setter를 포함해 완성하세요.  
  
  
* 문제 2  
AuthController 클래스를 생성하고,  
 /auth/login 경로에 대해 POST 요청을 처리하는 메서드를 작성하세요.  
  
* 문제 3  
POST 요청으로 받은 사용자 정보가 "user" / "1234" 와 일치할 경우 JWT를 생성하고,  
 그렇지 않으면 401 Unauthorized 응답을 반환하도록 작성하세요.  
  
* 문제 4  
JWT 생성을 위한 유틸 클래스 JwtUtil을 작성하세요.  
subject는 username  
  
  
발급 시간과 만료 시간을 설정  
  
  
서명 알고리즘은 HS256  
  
  
비밀 키는 "my-secret-key"  
  
  
  
* 문제 5  
JWT의 만료 시간을 1시간으로 설정하세요.  
 Java 코드로 현재 시각부터 1시간 뒤의 시간 객체를 생성하는 코드를 작성하세요.  
  
* 문제 6  
JwtUtil에서 생성된 JWT 토큰을 Bearer {token} 형태의 문자열로 반환하도록 메서드를 수정하세요.  
 예시 응답:  
"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."  
  

* 문제 7  
/auth/login API를 Talend API Tester에서 테스트하세요.  
 정상 입력 시 JWT가 발급되는지 확인하고, 응답 값을 복사해보세요.  
요청 JSON:  


{
  "username": "user",
  "password": "1234"
}


* 문제 8
잘못된 로그인 요청(비밀번호 오류)을 Talend에서 시도하고,
 응답 코드가 401인지, 응답 메시지가 "로그인 실패"인지 확인해보세요.


* 문제 9
발급받은 JWT 토큰을 https://jwt.io에 복사해 넣고,
 Payload 영역에 어떤 정보(sub, iat, exp)가 들어 있는지 확인해보세요.

* 문제 10
JWT가 클라이언트에게 발급되는 구조의 장점 3가지를 서술하세요.
 예: 세션 방식 대비 장점, 확장성, 서버 상태 의존 없음 등


## Day 5 프로그램 작성형 실습 문제 풀이

* 문제 1
    LoginRequest.java
    package com.example.jwt.dto;

    public class LoginRequest {
        private String username;
        private String password;

        public String getUsername() { return username; }
        public void setUsername(String username) { this.username = username; }
        public String getPassword() { return password; }
        public void setPassword(String password) { this.password = password; }
    }


* 문제 2

        AuthController.java (기본 뼈대)
        @RestController
        @RequestMapping("/auth")
        public class AuthController {
            private final JwtUtil jwtUtil;

            public AuthController(JwtUtil jwtUtil) {
                this.jwtUtil = jwtUtil;
            }

            @PostMapping("/login")
            public ResponseEntity<?> login(@RequestBody LoginRequest request) {
                // 로직은 다음 문제에서
                return null;
            }
        }

* 문제 3
인증 조건 분기 구현

        @PostMapping("/login")
        public ResponseEntity<?> login(@RequestBody LoginRequest request) {
            if ("user".equals(request.getUsername()) && "1234".equals(request.getPassword())) {
                String token = jwtUtil.generateToken(request.getUsername());
                return ResponseEntity.ok().body("Bearer " + token);
            } else {
                return ResponseEntity.status(401).body("로그인 실패");
            }
        }

* 문제 4

        JwtUtil.java
        package com.example.jwt.util;

        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;
        import org.springframework.stereotype.Component;

        import java.util.Date;

        @Component
        public class JwtUtil {
            private final String secretKey = "my-secret-key";
            private final long expiration = 1000 * 60 * 60; // 1시간

            public String generateToken(String username) {
                return Jwts.builder()
                    .setSubject(username)
                    .setIssuedAt(new Date())
                    .setExpiration(new Date(System.currentTimeMillis() + expiration))
                    .signWith(SignatureAlgorithm.HS256, secretKey)
                    .compact();
            }
        }


* 문제 5

    만료 시간 설정
        Date now = new Date();
        Date expiry = new Date(now.getTime() + 1000 * 60 * 60); // 1시간

* 문제 6

        Bearer prefix 포함
        return ResponseEntity.ok().body("Bearer " + token);


* 문제 7

        Talend 정상 요청 테스트
        요청 JSON:
        {
          "username": "user",
          "password": "1234"
        }

        예상 응답:
        Status: 200 OK


        Body: "Bearer eyJhbGciOiJIUzI1NiIs..."
        → 복사해서 jwt.io에서 확인 가능


* 문제 8

        Talend 오류 요청 테스트
        요청 JSON:
        {
          "username": "user",
          "password": "wrong"
        }

        예상 응답:
        Status: 401 Unauthorized


        Body: "로그인 실패"



* 문제 9

        jwt.io 결과 예시
        복호화 결과:
        {
          "sub": "user",
          "iat": 1727193100,
          "exp": 1727196700
        }

        sub: 사용자 이름

        iat: 발급 시각 (issued at)

        exp: 만료 시각 (expires at)

* 문제 10

        JWT 인증 구조의 장점 3가지
        서버가 세션을 저장하지 않아도 되므로 무상태(stateless) 유지 가능

        확장성과 성능 측면에서 유리함 (분산 환경에서도 토큰으로 인증 가능)

        프론트엔드에서 토큰만 있으면 자유롭게 API 요청 가능 (재로그인 필요 없음)



## Day 5 - JWT 로그인 인증 실습: 객관식 문제 (20문제)

문제 1. JWT는 무엇의 약자인가?  C   
A. Java Web Token   
B. Java Web Transport   
C. Json Web Token   
D. Java Wireless Token   
    
** 문제 2. JWT의 구성 요소로 올바른 것은? B
A. Key, Payload, Secret   
B. Header, Payload, Signature   
C. Token, Body, Footer   
D. Header, Body, Footer   
   
문제 3. JWT에서 Payload에 저장되는 정보는 무엇인가? C   
A. 사용자 인증 비밀번호   
B. 민감한 데이터   
C. 사용자 식별 정보와 클레임   
D. HTML 데이터   
   
문제 4. JWT의 Signature 부분은 어떤 용도로 사용되는가? B   
A. 토큰을 암호화하기 위해   
B. 발급자를 검증하기 위해   
C. 토큰을 압축하기 위해   
D. 토큰을 삭제하기 위해   
   
문제 5. JWT를 사용하는 가장 큰 이유 중 하나는? C   
A. 토큰을 이미지로 변환 가능   
B. 상태 정보를 서버에 저장   
C. 서버 무상태(stateless) 인증 가능   
D. 데이터 암호화를 자동 수행   
   
**문제 6. Spring Security에서 인증 없이 접근을 허용하는 경로 설정 방법은? C   
A. http.disable()   
B. .authorizeHttpRequests().anyRequest().denyAll()
C. .requestMatchers("/auth/**").permitAll()ㅍ
D. .disableAllSecurity()   
   ㅍ
문제 7. 로그인 요청이 성공했을 때 서버가 클라이언트에게 반환하는 응답은? B   
A. JSON 에러 메시지      
B. JWT 토큰   
C. 비밀번호   
D. 인증번호   
   
문제 8. JWT는 어느 헤더에 포함되어 전송되는가? C   
A. Accept   
B. Content-Type   
C. Authorization   
D. Token-Header   
   
문제 9. JwtUtil 클래스의 주요 책임은? C   
A. 사용자 비밀번호 암호화   
B. HTTP 요청 처리   
C. JWT 토큰 생성   
D. DB 연결   
   
**문제 10. JWT 생성 시 만료 시간 설정을 위해 사용하는 객체는? B   
A. LocalDate   
B. Date   
C. Timestamp   
D. ZonedDateTime   
   
문제 11. JWT를 디코딩하여 Payload를 볼 수 있는 사이트는? B   
A. jwt.org   
B. jwt.io   
C. token.dev   
D. spring.io   
   
문제 12. 다음 중 올바른 로그인 요청 JSON은? B   
A. { "id": "user", "pw": "1234" }   
B. { "username": "user", "password": "1234" }   
C. { "login": "user", "pass": "1234" }   
D. { "user": "user", "pass": "1234" }   
   
** 문제 13. @RequestBody 어노테이션은 무엇을 의미하는가? C   
A. 응답 데이터를 JSON으로 변환   
B. URL 파라미터에서 데이터를 읽음   
C. 요청 본문에서 JSON 데이터를 바인딩   
D. GET 요청을 수행함   
   
문제 14. Talend API Tester에서 사용하는 HTTP 메서드는? D   
A. GET   
B. PUT   
C. DELETE   
D. POST   
   
문제 15. JWT의 만료 시간(exp)을 설정할 때 기준이 되는 단위는? B   
A. 초(second)   
B. 밀리초(millisecond)   
C. 분(minute)   
D. 일(day)   
   
문제 16. SecurityConfig.java에서 사용된 인증 전략은? C   
A. 기본 인증   
B. 쿠키 기반 인증   
C. JWT 기반 인증 (준비단계)   
D. 세션 기반 인증   
   
** 문제 17. 로그인 실패 시 반환되는 HTTP 상태 코드는? B   
A. 200   
B. 401   
C. 403   
D. 500   
   
문제 18. 다음 중 JWT 사용의 장점이 아닌 것은? D   
A. 확장성과 무상태성   
B. 보안성 강화   
C. 토큰 재사용 방지   
D. 서버에 세션 저장 필수   
   ㅍ
**문제 19. 아래 중 HS256 알고리즘은 어떤 방식인가? D   
A. 대칭키 해싱   
B. 비대칭키 암호화   
C. RSA 방식   
D. HMAC 기반 암호화   
   
문제 20. 클라이언트가 발급받은 JWT를 서버에 다시 보낼 때 쓰는 방식은? C   
A. 쿼리 스트링   
B. 쿠키
C. Authorization 헤더   
D. URL Path


[정답 및 해설]   
1. C — Json Web Token   
2. B — Header, Payload, Signature   
3. C — 사용자 식별 정보와 클레임   
4. B — 발급자를 검증하기 위해   
5. C — 서버 무상태(stateless) 인증 가능   
6. C — .requestMatchers("/auth/**").permitAll()   
7. B — JWT 토큰   
8. C — Authorization   
9. C — JWT 토큰 생성   
10. B — Date   
11. B — jwt.io   
12. B — { "username": "user", "password": "1234" }   
13. C — 요청 본문에서 JSON 데이터를 바인딩   
14. D — POST   
15. B — 밀리초(millisecond)   
16. C — JWT 기반 인증 (준비단계)   
17. B — 401   
18. D — 서버에 세션 저장 필수   
19. D — HMAC 기반 암호화   
20. C — Authorization 헤더   
   
   
## Day 5: JWT 로그인 인증 실습 – 단답형 문제 (텍스트 모드)   
   
   
1. JWT에서 사용자를 식별하는 정보를 담는 필드는 무엇인가요? sub   
2. JWT는 총 몇 개의 파트로 구성되나요? 3개 (Header, Payload, Signature)   
3. JWT를 서버가 클라이언트에 반환할 때 주로 어떤 HTTP 헤더에 담아서 전송하나요? Authorization   
4. JWT의 Signature는 어떤 정보를 기반으로 생성되나요? Header + Payload + Secret Key   
5. JWT의 만료 시간을 설정하기 위해 사용하는 Java 클래스는 무엇인가요? java.util.Date   
6. Spring Security에서 인증 없이 허용할 경로를 설정할 때 사용하는 메서드는 무엇인가요? requestMatchers().permitAll()   
7. JWT를 생성하는 데 사용된 서명 알고리즘은 무엇인가요? HS256   
8. Spring Security 설정에서 csrf 보안을 비활성화하는 메서드는 무엇인가요? http.csrf().disable()   
   
9. 로그인 API의 엔드포인트 URL은 무엇인가요?    
POST /auth/login   
   
10. 정상 로그인 시 JWT 토큰을 생성하는 유틸리티 클래스 이름은 무엇인가요? JwtUtil   
11. JWT 토큰을 복호화하여 내용을 확인할 수 있는 대표적인 웹사이트는 어디인가요? jwt.io   
12. JWT의 “iat” 필드는 무엇을 의미하나요? 발급 시각 (issued at)   
13. JWT의 “exp” 필드는 어떤 역할을 하나요? 만료 시각 (expires at)   
14. 로그인 요청에 포함되는 JSON의 키 이름 두 가지는 무엇인가요? username, password   
15. 로그인 실패 시 반환되는 HTTP 상태 코드는 무엇인가요? 401   
16. Spring Security의 인증 처리에서 “/auth/**” 경로에 대해 설정된 접근 권한은 무엇인가요? PermitAll()   
17. 로그인 성공 시 반환되는 JWT는 어떤 문자열로 시작하나요?  Bearer   
18. JWT는 어떤 방식으로 서버 상태를 관리하나요? (상태 있음/무상태) 무상태 (Stateless)   
19. Java에서 현재 시간을 기준으로 만료 시간 1시간 뒤를 생성하는 방법은 무엇인가요? new Date(System.   currentTimeMillis() + 1000 * 60 * 60)   
20. JWT를 사용하는 가장 큰 장점 세 가지 중 하나를 쓰세요. 서버 세션 없이 인증 가능   
   
## Day 5: JWT 로그인 인증 실습 – 단답형 정답 (텍스트 모드)   
1. sub   
2. 3개 (Header, Payload, Signature)   
3. Authorization   
4. Header + Payload + Secret Key   
5. java.util.Date   
6. requestMatchers().permitAll()   
7. HS256   
8. http.csrf().disable()   
9. /auth/login   
10. JwtUtil   
11. jwt.io   
12. 발급 시각 (issued at)      
13. 만료 시각 (expires at)   
14. username, password   
15. 401   
16. permitAll   
17. Bearer   
18. 무상태 (Stateless)   
19. new Date(System.currentTimeMillis() + 1000 * 60 * 60)   
20. 서버 세션 없이 인증 가능   
   