# 📘 DB와  ORM
   
## 데이터베이스   
클라이언트 프리젠테이션 비즈니스 인티그레이션 데이터리소스   
-----------------------------------------------------
                                                      데이터베이스   
                                                     -------------   
   
                                       ORM(인특레이션티어)   
                                       ----------------   

                 ---------------      
                 백엔드 서버(MVC)   
   
 프론트엔드   
-----------   
 요청(URL)       Controller Service       Entity         Mysql   
                            Repository   
## ORM   
   클래스   : 테이블    = 1:1   
   객체     : 행        = 1:1   
   멤버필드 : 컬럼      = 1:1     
   
## 스프링 부트   
JPA --> Entity   

## `@AllArgsConstructor` : 모든 필드 매개변수 생성자   
## `@NoArgsConstructor` : 파라미터 없는 기본 생성자   
## `@Entity`  
데이터베이스 매핑   
Java Persistence API(JPA 애노테이션)   
이 클래스를 DB 테이블과 매핑함을 의미   
--> 이 클래스는 엔티티이며, DB 테이블에 해당하는 클래스   
   
    @Entity   
    public class User{   
        @Id // 대표키 지정   
        @GeneratedValue(strategy= GenerationType.IDENTITY) // DB가 자동으로 1씩 증가   
        private Long id; // 대표키   
    }   
   
## `@ToString`  
 rombok에서 제공하는 애노테이션, return 필요   
 클래스의 필드를 기반으로 자동으로 toString()메서드를 생성   
 객체를 생성하는 메소드, 객체자신의 값 리턴을 위해서 

    if(obj1.equals(obj2)){   
   
    }else{   
   
    }
    String toString(){   
        return result;   
    }   
   
## JPA 에서 `@Entity`가 의미 하는 것   
    @Entity   
    @toString   
    public class User {   
        @Id   
        private Long id;   
        private String name;   
        private String email;   
    }   
**User 클래스** ---> 데이터베이스의 user테이블과 매핑된다.   
**id, name, email** -->user 테이블의 칼럼   
**@Id** --> 기본 키(primary key) 칼럼   
**@ToString** --> 디버깅할때 User(id1,name=홍길동, email=aa@bbb.com) 형태로 자동 출력   
   
## 데이터베이스 연동을 위한 필요한 구성   
1. 엔티티 클래스(Entity)   
2. Repository 인터페이스(JPaReposity 상속)   
3. 서비스 클래스(비즈니스 로직 처리)   
4. DB 설정(application.yml또는 application.properties)   
   
## Repository 예시   
    public interface UserRepository extends JpaRepository<User, Long>{   
        User findByEmailString email);   
    }   

## 데이터베이스 설정 예시(application.yml)      
    spring :      
      datasource :   
        userl: jdbc:mysql://localhost:3306/testdb      
        username:root      
        password:1234      
      jpa:      
        Hibernate:      
          ddl_auto:update   
        show-sql:true   
   
## 전체 동작 흐름   
  Spring Boot 실행 시 @Entity 클래스 기반으로 테이블을 매핑하거나 생성   
  UserRepository로 데이터를 조회/저장   
  서비스나 컨트롤러 계층에서 비즈니스 로직 수행   
   
## 실무에서 주의해야 할것   
1. 양방향 연관관계 vs 단방향    
양방향 설정할 때 반드시 ""무한루프"" 주의   
   
        @ToString   
        @Entity   
        public class Member {   
            @ManyToOne   
            private Team team;   
        }   

        @ToString   
        @Entity   
        public class Team{   
            @OneToMany(mapedBy = "team")   
            private List<Member> members;   
        }   

    ---> @ToString 이 서로를 호출하면서 StackOverflow 발생 가능   
    ---> ""해결방안""   
       @ToString(exclude="otherEntity")   
       @JsonIgnore   
       @EQualsAndHashCode(exclude="...")   

2. 엔티티 생성 시 Setter 남용금지   
객체가 생성된 다음에 필요에 의해서 setter 호출하면 전후 간격 시간에 갭이 발생   
그 상태에서 오류 발생 가능성 높음.   
실무에서는  Setter 사용을 지양하고, 생성자 or Builder 패턴을 사용하라   
    public class User{   
        private String name;   
        private String email;   
        protected User(){   
   
        }   
        public User(String name, String email){
            this.name = name;
            this.email = email;

        }
    }
   
3. 지연로딩(LAZY)주의   
실무에선 관계 필드에 fetch = FetchType.LAZY를 쓰는게 기본   
단, 조회시 LazyInitilazationException이 안 나도록 주의해야함.   
데이터를 언제 로딩할지 결정하는 옵션입니다.
LAZY는 실제 데이터를 사용할 때까지 로딩을 미루는 전략입니다.

@ManytoOne(fetch=FetchType.LAZY)   
private Team team;   
    
        
    @Entity
    public class Member {

        @Id @GeneratedValue
        private Long id;

        private String name;

        @ManyToOne(fetch = FetchType.LAZY)
        private Team team;  // 연관된 엔티티는 나중에 로딩됨
    }


    Member member = em.find(Member.class, 1L);  // 여기선 team을 로딩하지 않음
    System.out.println(member.getName());


    System.out.println(member.getTeam().getName());  // 이 시점에 team 쿼리 실행됨!



| 설정             | 로딩 시점        | 장점                 | 단점             |
| -------------- | ------------ | ------------------ | -------------- |
| `LAZY` (지연로딩)  | 실제 사용할 때     | 성능 최적화, 불필요한 쿼리 방지 | N+1 문제 주의 필요   |
| `EAGER` (즉시로딩) | 엔티티 조회할 때 즉시 | 사용 간단함             | 불필요한 데이터까지 로딩됨 |



## 엔티티(Entity) 설계 원칙   
`@Entity` --> DB 테이블과 매핑되는 클래스   
`@Id` --> 기본 키 지정   
`@GeneratedValue` --> 자동 증가 시퀀스 설정(1,2,3,4,....)   
`@Column` --> 칼럼 세부 설정(nullable(null가능),unique(유일한값) 등)   
   
## 연관관계 매핑   
**1:N --> @OneToMany**                 --> 성능주의(N 쿼리 발생)   
**N:1 --> @ManyToOne(fetch = LAZY)**   --> 기본 설정은 LAZY   
**1:1 --> @OneToOne**                  --> 외래키 주의(null이거나 pk)      
**N:N-->  @ManyToMany**               --> 실무에서는 사용안함(중간 테이블 엔티티로 분리)   
* 실무에서는 단방향 매핑이 안전함. 양방향은 mappedBy/@JsonIgnore/@ToString(exclude 사용)   

## 데이터베이스 실무적 주의사항   
* **정규화/비정규화** --> 3 정규형까지까지는 기본, 성능 고려시 비정규화(중복 허용)도 고려   
* **명확한 기본 키**  --> surrogate key(id) natural key 구분하고 ID 전략 지정   
  - surrogate key :  ID (1, 2, 3) 주민등록번호
  - Natural Key : 이메일 주소 등
*  **제약조건 정의** --> Not null, Unique, Check, Default등 반드시 명시   
* **인덱스 설계** --> 자주 조회되는 칼럼에 적절한 Index 생성(과도한 인덱스는 오히려 안좋음)   
* **테이블이 단순 조회성이면** 인덱스 설정 유용, 수정, 삭제 등록이 많으면 인덱스를 많이 잡으면 안됨.   
   - 사전 --> 단어가 매번 추가되면 고부하 될 수 있음   
* **Enum은 별도 테이블 or Varchar** -> DB에  Enum을 직접 쓰면 이식성 떨어짐   
   
## 성능 관련 주의사항   
**인덱스 오용 방지** --> 조건절에 함수 사용시 인덱스 미사용( Where Date(Created_at))   
**N + 1문제** --> ORM 사용시 JOIN 안 쓰면 연관 엔티티 수만큼 쿼리 발생   
**Batch 처리** --> 대용량 insert/update 시 반드시 Batch 처리 고려   
**쿼리 튜닝** --> Explain, 실행계획 활용해서 인덱스 여부, full scan 여부 체크   
   
## 데이터 정합성과 무결성   
트랜잭션 처리 -> 논리 단위로 commit/rollback 정확하게 묶기   
작업이 여러개일경우에는 묶어서 한꺼번에 commit 해야함.   
거래1 \   
거래2  한번에commit 해야함.   
거래3 /   
   
외래키(FK) --> 가능한 설정, 단 복잡한 시스템에선 ""논리적 관리""도 고려   
 예) 홍길도 직원 입사일, 상사, 월급, 부서   
 Cascade 주의 --> ON DELETE CASCADE 남용시 실수로 다 삭제될 수 있음.   
 동시성 제어 --> Optimistic Locking(@Version) or Perssimistic Locking 고려   
