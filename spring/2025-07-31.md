#   
## Day3 유효성 검증 & 예외 처리 실습(Talend)   
인증 - 유효한 사용자인지 체크   
인가 - 인증된 사용자의 권한 체크   

* 강의 목표   
 DTO 유효성 검증(@Valid 및 제약 어노테이션 적용)   
 글로벌 예외 처리기(@ControllerAdvice) 구현   
 Talend로 검증 실패 시 응답 포맷 확인 및 개선   

 * 강의 내용   
 1. DTO 유효성 검증 애노테이션 적용   
 --> @NotBlank, @Size, @Email, @NotNull 등   
 2. Valid와 BindingResult의 관계 이해   
 3. MethodArgumentNotValidException 처리   
 4. 전역 예외 처리기(GlobalExceptionHandler) 작성   
 5. Talend 유효성 실패 케이스 테스트 및 JSON 에러 메시지 확인   
   
 * 금융권에서는 공부많이 해야한다. 경력자도 공부한다.   
 * 노트 정리도 필요하고, 중요한 부분은 암기도 필요하다.   
   

* 실습 코드 전체 : 유효성 검증 및 예외 처리 적용   
   
  PostRequestDTO.java  

      package com.exmaple.board.dto;
      import jakarta.validation.constraints.NotBlank; //bilt-in 방식
      import jakarta.validation.contraints.Size;

      public class PostRequestDTO{
        @NotBlank(message = "제목은 필수입니다.")
        @Size(min = 2, max = 100, message="제목은 2~100자여야 합니다.")
        private String title;
        
        @NotBlank(message = "내용은 필수입니다")
        private String content;

        public String getTitle(){ return title; }
        public void setTitle(String title){ this.title = title; }
        public String getContent(){ return content; }
        public void setContent(String content{ this.content = content; })
      }


  PostController.java(수정됨)
      package.com.example.board.controller;

      import com.example.board.dto.PostRequestDTO;
      import com.example.boardservice.PostService;
      import jakarta.validation.Valid;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;


      @RestController

      @RequestMapping("/posts")
      public class Postcontroller{

        private final PostService postSerice; //값 초기화
        
        public Postcontroller(PostService postService){
            this.postService = postService;
        }
        public ResponseEntity<String> create(@RequestBody @Valid PostRequestDTO dto){
          postService.createPost(dto);
          return ResponseEntity.status(201).body("게시글이 등록되었습니다.");
        }
      }

GlobalExceptionHandler.java

    package com.example.board.exception;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.bind.annotation.REstControllerAdvice;
    import org.springframework.web.ind.MethodArgumentNotValidException;

    import java.util.HashMap;
    import java.util.Map;

    @ReseControlleRAdvice
    public class GlobalExceptionHandler{
      public ResponseEntity<Map<String, String>> handleValidationErrors( MethodArgumentNotValidException ex){
        Map<Strig, String> errors = new HashMap<>();
        
        ex.getBindingResult()
        .getFieldErros()
        .forEach(
          error -> errors.put(error.getField(), error. getDefaultMessage())
        );

      }
    }

## Day 3 과제
1. PostRequestDTO에 유효성 검증 애노테이션을 적용하고, 직접 요청시 검증이 동작되는지 확인하세요.

2. Talend API Tester를 통해 다음 요청을 보내고 JSON 에러 메시지를 캡처하세요.
{
  "title" : "",
  "content" : "내용"
}
{
  "title" :"A"
  "content" : ""
}
3. GlobalExceptionHandler에서 응답 포맷을 "필드명" : "필드 메시지" 구조로 확인하세요.

4. 예외 응답 JSON을 보고 클라이언트 입장에서 어떤 부분이 개선되었는지 분석 보고서를 작성하세요.

등록불가시 어떤항목을 놓쳤는지 알수 있게 되었음.


## GET/POST API 구현
* GET vs POST
  GET --> 데이터 조회, URL(QueryString), 보안 낮음,/users?name=kim
  POST --> 데이터 등록, Body(JSON), 보안 높음, /user + JSON

* @RequestParam vs @PathVariable
  @RequestParam --> 쿼리 스트링으로 전달, /user?id=3
  @PathVariable --> URI 경로 자체에서 값 추출, /user/3

* 실습
  /user?id=3
  /user/3



## Day 3 과제 풀이 – 유효성 검증 및 예외 처리

1️. PostRequestDto에 유효성 검증 어노테이션 적용
목적: 요청 값이 비어 있거나 조건을 만족하지 않을 경우 400 오류 응답
PostRequestDto.java

    package com.example.board.dto;

    import jakarta.validation.constraints.NotBlank;
    import jakarta.validation.constraints.Size;

    public class PostRequestDto {

        @NotBlank(message = "제목은 필수입니다.")
        @Size(min = 2, max = 100, message = "제목은 2자 이상 100자 이하여야 합니다.")
        private String title;

        @NotBlank(message = "내용은 필수입니다.")
        private String content;

        // getters, setters
    }


PostController.java

    @PostMapping
    public ResponseEntity<String> createPost(@RequestBody @Valid PostRequestDto dto) {
        postService.createPost(dto);
        return ResponseEntity.status(201).body("게시글 등록 완료");
    }
--> 반드시 @Valid가 붙어 있어야 검증이 작동합니다.


2️. Talend API Tester 요청 → JSON 에러 메시지 확인
❌ 테스트 1

    {
      "title": "",
      "content": "내용"
    }


✔️ 응답 JSON 예시:

    {
      "title": "제목은 필수입니다."
    }


❌ 테스트 2

    {
      "title": "A",
      "content": ""
    }


✔️ 응답 JSON 예시:

    {
      "title": "제목은 2자 이상 100자 이하여야 합니다.",
      "content": "내용은 필수입니다."
    }
   
   
3️. GlobalExceptionHandler 예외 포맷 구성
GlobalExceptionHandler.java

    @RestControllerAdvice
    public class GlobalExceptionHandler {

        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<Map<String, String>> handleValidationErrors(MethodArgumentNotValidException ex) {
            Map<String, String> errors = new HashMap<>();
            ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage())
            );
            return ResponseEntity.badRequest().body(errors);
        }
    }


    ✔️ 포맷 구조:
    {
      "필드명": "오류 메시지"
    }
   
   
    예시:
    {
      "title": "제목은 필수입니다.",
      "content": "내용은 필수입니다."
    }   

4️. 클라이언트 입장에서 개선된 점 분석   
항목 기존 (Day 2 이전) 개선된 이후 (Day 3)   
   
오류 응답 없음   
유효하지 않은 입력도 처리됨   
요청 오류에 대한 명확한 피드백 제공   
메시지 구조 없음   
상태코드만 확인 가능   
"필드명": "오류 메시지"로 직관적인 응답   
사용자 혼란 발생   
어떤 필드가 문제인지 알 수 없음   
클라이언트가 즉시 수정 가능   

* 분석 보고서 요약:   
  클라이언트가 어떤 필드가 잘못되었는지 명확히 파악 가능   
  UI에서 실시간 검증 메시지로 활용 가능   
  사용자 경험(UX) 및 API 신뢰성 향상   
   

## Day 3 작업형 실습문제 10문제

문제 1   
PostRequestDto 클래스에 title과 content 필드를 선언하고,   
 각각에 대해 @NotBlank 검증 어노테이션을 적용해보세요.   


문제 2   
title 필드에는 2자 이상 100자 이하의 길이 제한을 적용해보세요.   
 적절한 메시지도 함께 설정해보세요.   


문제 3
PostController 클래스에서 게시글 등록 API에 @Valid를 적용하고,   
 DTO 검증이 제대로 작동하는지 확인해보세요.   

   
문제 4
Talend API Tester를 이용하여 다음 요청을 전송하고, 응답으로 어떤 오류 메시지가 반환되는지 확인해보세요.   

    {
      "title": "",
      "content": "내용 있음"
    }


문제 5
또 다른 잘못된 요청을 전송해보세요:

    {
      "title": "A",
      "content": ""
    }
   

Talend에서 받은 응답을 JSON 형태로 캡처하고, 메시지를 분석해보세요.   


문제 6   
글로벌 예외 처리기 GlobalExceptionHandler를 생성하고,   
 MethodArgumentNotValidException을 처리하여   
 "필드명": "오류 메시지" 구조로 JSON 응답을 구성해보세요.   


문제 7   
예외 처리기에서 Map<String, String>을 이용하여 여러 필드의 오류 메시지를 수집하는 코드를 작성해보세요.   


문제 8   
Talend를 통해 /posts 요청을 보낼 때   
정상 요청   

잘못된 요청 (필드 누락, 빈 문자열)   
 두 가지를 비교 테스트하고 상태 코드 차이를 확인해보세요.   


문제 9   
예외 응답 구조가 사용자에게 어떤 도움이 되는지,   
 클라이언트(프론트엔드) 개발자 입장에서 어떤 점이 개선되었는지 글로 정리해보세요.   


문제 10   
응답 메시지를 다국어로 대응하거나 사용자 친화적인 문장으로 확장하고 싶다면,   
 어떤 방식(i18n, 메시지 프로퍼티 등)을 적용할 수 있을지 조사해보고 간단히 설명해보세요.   


## Day 3 작업형 실습문제 풀이

문제 1
PostRequestDto 클래스에 @NotBlank 적용

      풀이
      public class PostRequestDto {
          @NotBlank(message = "제목은 필수입니다.")
          private String title;

          @NotBlank(message = "내용은 필수입니다.")
          private String content;
      }




문제 2   

      @Size(min = 2, max = 100) 설정   
      풀이   
      @Size(min = 2, max = 100, message = "제목은 2자 이상 100자 이하로 입력해주세요.")   
      private String title;   
    
   

   
문제 3   
@Valid를 적용한 컨트롤러   

      PostController.java   
      @PostMapping   
      public ResponseEntity<String> create(@RequestBody @Valid PostRequestDto dto) {   
          postService.createPost(dto);   
          return ResponseEntity.status(201).body("게시글이 등록되었습니다.");   
      }   
    
문제 4   

      Talend 요청 (title이 빈 문자열)   
      {   
        "title": "",   
        "content": "내용 있음"      
      }
      
      예상 응답   
      {
        "title": "제목은 필수입니다."
      }

      --> 상태 코드: 400 Bad Request


문제 5

      Talend 요청 (title이 1자, content 없음)
      {
        "title": "A",
        "content": ""
      }

      예상 응답
      {
        "title": "제목은 2자 이상 100자 이하로 입력해주세요.",
        "content": "내용은 필수입니다."
      }

      --> 상태 코드: 400 Bad Request



문제 6
글로벌 예외 처리기 생성

    GlobalExceptionHandler.java
    @RestControllerAdvice
    public class GlobalExceptionHandler {

        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<Map<String, String>> handleValidationErrors(MethodArgumentNotValidException ex) {
            Map<String, String> errors = new HashMap<>();
            ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage())
            );
            return ResponseEntity.badRequest().body(errors);
        }
    }

문제 7
에러 메시지를 Map<String, String>으로 구성   
코드 설명   

    Map<String, String> errors = new HashMap<>();
    ex.getBindingResult().getFieldErrors().forEach(error ->
        errors.put(error.getField(), error.getDefaultMessage())
    );

    출력 예:
    {
      "title": "제목은 필수입니다.",
      "content": "내용은 필수입니다."
    }



문제 8
정상 요청 vs 오류 요청 비교 (Talend 테스트)
정상 입력

    {
      "title": "테스트 제목",
      "content": "테스트 내용"
    }

    ✔ 상태 코드: 201 Created
    ✔ 응답: "게시글이 등록되었습니다."
    오류 입력


{
  "title": "",
  "content": ""
}

    ✔ 상태 코드: 400 Bad Request
    ✔ 응답:
    {
      "title": "제목은 필수입니다.",
      "content": "내용은 필수입니다."
    }



문제 9
예외 응답 포맷의 개선 효과 정리
답안 예시
    프론트엔드에서 필드별 오류를 UI에 바로 매핑 가능

    사용자에게 어떤 필드가 잘못되었는지 명확히 안내 가능

    전체적인 사용자 경험(UX)이 향상됨

    REST API 신뢰도가 높아짐



문제 10
예외 메시지 다국어/친화적 메시지 구성
답안 예시

    ValidationMessages.properties 파일을 생성하여 메시지 추출   

    @NotBlank(message = "{post.title.notBlank}") 형태로 작성   

    스프링에서 제공하는 MessageSource 빈을 통해 메시지 다국어 대응   

    사용자 친화적인 말투로 메시지를 작성 (ex. “제목을 입력해 주세요”)   
