# 📘  알고리즘 코딩 테스트

* 프로그램 실행은 시간복잡도 기준으로  선택해야한다.   

## 📦 시간 복잡도

### 시간 복잡도 표기법
- 알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다.
- 일반적으로 1억 번의 연산을 1초의 시간으로 간주하여 예측한다

* 시간복잡도는 연산의 횟수이다.   
* 빅-오 표기법 O(n)을 기준으로 수행시간을 계산하는것이 좋다.     

### 시간 복잡도 정의하기
- 빅 오메가: 최선일때 연산횟수 표기법
- 빅-세타 : 보통일때 연산횟수 표기법
- 빅-오 : 최악일때 연산횟수 표기법

### 시간 복잡도 도출 기준
- 상수는 시간 복잡도 계산에서 제외한다.
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.
- 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출한다.   
- for문이 여러개일 경우에는 그중에서 제일 많이 반복된 기준으로 1개만 반복횟수가 된다.   


## 📦 디버깅

### 코드의 논리오류 어떻게 잡을까?   
문법오류나 논리오류를 찾아 바로잡는 과정을 디버깅이라고 한다.   
   

### 디버깅의 중요성
- 문법오류나 논리오류를 찾아 바로잡는 과정을 디버깅이라고 한다.

### 디버깅하는법
- 인텔리제이나, 이클립스에서 중단점을 활용한다. break point   
- 이클립스  Expressions 기능을 활용하면 된다. 
- F6 키를 이용해서 한줄씩 실행하면서 변수값이 어떻게 바뀌어지는지를 살펴볼수 있다.   
   

## 📦 배열과 리스트
### 배열
- 배열은 메모리의 연속공간에 채워져 있는 형태의 자료구조이다.
- 인덱스값을 사용하여 바로 접근할 수 있다.
- 새로운 값 삽입, 삭제 어려움, 변경하려면 인덱스 주변의 값을 이동해야함.
- 한번 선언하면 크기 변경 불가능.
- 구조가 간단하여 코딩 테스트에서 많이 사용.

### 리스트
- 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.
- 값에 접근하는 속도가 느리다.
- 데이터 삽입 삭제 속도가 빠르다.
- 크기가 변하기 쉬운 데이터를 다룰때 적절하다.
- 포인터 저장 공간이 필요하므로 배열보다 구조가 복잡하다.

## 구간합

- 먼저 합 배열을 구해야 한다.
- 기존의 배열을 전처리한 배열이라 생각하면 된다.
- 시간 복잡도가 O(N)에서 O(1)로 감소한다.



## 🛠️ 알고리즘 실습 문제   
   

* 입력과 출력에 맞추어 알고리즘 작성하시오.   
* 입력  
5 3  
5 4 3 2 1  
1 3  
2 4  
5 5  

* 출력  
12  
9  
1 


            import java.io.BufferedReader;
            import java.io.IOException;
            import java.io.InputStreamReader;
            import java.util.StringTokenizer;

            // 11659 문제
            public class areaHab {
                public static void main(String[] args) throws IOException {
                    BufferedReader bufferedReader
                            = new BufferedReader(new InputStreamReader(System.in));
                    StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
                    int suNo = Integer.parseInt(stringTokenizer.nextToken());
                    int quizNo = Integer.parseInt(stringTokenizer.nextToken());

                    long[] S = new long[suNo + 1];
                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());
                    for (int i = 1; i <= suNo; i++) {
                        S[i] = S[i - 1] + Integer.parseInt(stringTokenizer.nextToken());
                    }

                    for (int q = 0; q < quizNo; q++) {
                        stringTokenizer = new StringTokenizer(bufferedReader.readLine());
                        int i = Integer.parseInt(stringTokenizer.nextToken());
                        int j = Integer.parseInt(stringTokenizer.nextToken());
                        System.out.println(S[j] - S[i - 1]);
                    }

                }
            }


# ✅ 문제     
## ● 단답형 문제 20개   
1) 빅-오(Big-O) 표기법에서 O(n²)은 무엇을 의미하는가? 입력크기 커질수록 시간 비례함   
2) 시간 복잡도 중 일반적으로 코딩 테스트에서 사용하는 표기법은 무엇인가? Big-O 표기법   
3) 배열과 리스트의 가장 큰 차이점은 무엇인가? 배열은 연속된 메모리, 리스트는 포인터   
4) 누적 합 배열에서 구간 [i, j]의 합을 구하는 공식은 무엇인가? S[j]-S[i-1]   
5) 배열에서 크기를 자유롭게 늘리거나 줄일 수 없는 이유는?  크기 고정이므로 연속된 공간 사용하기 때문   
6) 디버깅이 필요한 이유는 무엇인가? 논리적, 문법적 오류 수정   
7) 디버깅을 위한 도구 중 중단점을 설정하는 기능을 무엇이라 하는가?  Break Point   
8) 버블 정렬의 시간 복잡도는 무엇인가? O(n²)   
9) 병합 정렬의 평균 시간 복잡도는 무엇인가? O(n log n)   
10) 구간 합 알고리즘에서 사용하는 배열의 이름은? 합 배열 또는 누적 합 배열   
11) 이중 for문이 있을 경우 일반적으로 시간 복잡도는 어떻게 되는가? O(n²)   
12) 알고리즘의 성능을 비교할 때 주로 고려하는 측정 기준은 무엇인가? 시간 복잡도   
13) 배열은 어떤 자료형만 저장할 수 있는가? 같은 자료형   
14) 리스트에서 값을 삽입할 때 배열보다 유리한 이유는? 중간 삽입/삭제가 용이   
15) 리스트에서 사용되는 기본 단위 구조는 무엇인가? 노드 (값 + 포인터)   
16) 누적 합을 사용할 때 시간 복잡도의 이점은? 구간 합을 O(1)에 구할 수 있다   
17) 백준 11659번 문제의 핵심 알고리즘은 무엇인가? 누적 합(Prefix Sum)   
18) 배열 A가 있을 때 합 배열 S의 초기값 S[0]은 얼마인가? 0   
19) 합 배열을 구할 때 사용하는 수식은? S[i] = S[i-1] + A[i]   
20) 반복문 안에서 인덱스 범위를 벗어나면 발생하는 오류는 무엇인가? IndexError   
   
## 객관식 문제   
21. 다음 중 시간 복잡도가 가장 낮은 것은? B   
A. O(n)   
B. O(log n)   
C. O(n2)   
D. O(2n)   
   
22. 다음중 배열의 특징으로 틀린 것은? B   
A. 인덱스를 통해 빠르게 접근 가능하다   
B. 크기를 유동적으로 조절할 수 있다.   
C. 같은 자료형만 저장한다.   
D. 메모리의 연속 공간을 사용한다.   
   
23. 구간 합을 빠르게 구하는 알고리즘은 무엇을 활용하는가? B   
A. 이진 탐색   
B. 누적 합   
C. 정렬   
D. 슬라이딩 윈도우   
   
24. 디버깅의 정의로 올바른 것은? B   
A. 프로그램 속도를 높이는 과정   
B. 오류 코드를 찾아 수정하는 과정   
C. 변수를 최적화하는 과정   
D. 반복문을 줄이는 과정   
   
25. 리스트 구조의 특징으로 옳은 것은? C   
A. 메모리 연속 공간을 사용한다.   
B. 값 이동이 많아 성능이 낮다.   
C. 포인터로 연결되어 있다.   
D. 인덱스로 빠르게 접근 가능하다.   
   
26. 다음 중 시간 복잡도가 가장 높은 알고리즘은? D   
A. O(n log n)   
B. O(n)   
C. O(1)   
D. O(2n)   
   
27. 다음 중 시간 복잡도 분석이 중요한 이유는? B   
A. 변수 초기화를 줄이기 위해   
B. 실행 시간 초과를 피하기 위해   
C. 프로그램 종료를 빠르게 하기 위해   
D. 디버깅을 위해   
   
28. 다음 중 누적 합이 필요한 상황은? C   
A. 데이터 삭제   
B. 정렬   
C. 특정 범위의 합 계산   
D. 해시 처리   
   
29. 다음 중 리스트에서 특정 노드에 접근할 때 가장 비효율적인 방법은? C   
A. 맨 앞 접근   
B. 맨 뒤 접근   
C. 중간 노드 탐색   
D. 포인터 순회   
   
30. 다음 중 코딩 테스트에서 주의해야 할 오류가 아닌 것은? D   
A. 변수 초기화 오류   
B. 인덱스 범위 오류   
C. 반복문 누락   
D. 주석처리   
   
31. 디버깅을 도와주는 툴은 무엇인가? B   
A. 컴파일러   
B. 디버거   
C. 파서   
D. 인터프리터   
   
32. 시간 제한이 1초일때 대략 몇 번의 연산까지 허용되는가? D   
A. 천 번   
B. 만 번   
C. 백만 번   
D. 억 번   
   
33. 리스트의 노드는 어떤 두 구성 요소로 이루어지는가? B   
A. 값과 인덱스   
B. 값과 포인터   
C. 포인터와 위치   
D. 인덱스와 배열   
   
34. 구간 합에서 구간이 100,000일때 비효율적인 알고리즘은? C   
A. 누적 합   
B. 정렬 후 합계 계산   
C. O(n) 반복 계산   
D. prefix sum   
   
35. 배열의 단점으로 옳지 않은 것은? C   
A. 고정 크기   
B. 삽입/삭제 어려움   
C. 인덱스 접근이 느림   
D. 메모리 낭비   
   
36. 이중 for문의 시간 복잡도는 일반적으로 어떻게 되는가? C   
A. O(n)   
B. O(log n)   
C. O(n2)   
D. O(1)   
   
37. 리스트에서 노드를 연결하는 방식은? B   
A. 배열 연결   
B. 포인터 연결   
C. 인덱스 지정   
D. 함수 호출   
   
38. 다음 중 시간 복잡도가 가장 빠른 알고리즘은? A   
A. O(1)   
B. O(n)   
C. O(n2)   
D. O(n log n)   
   
39. 정렬 알고리즘 중 평균 시간 복잡도가 가장 낮은 것은? C   
A. 버블 정렬   
B. 삽입 정렬   
C. 병합 정렬   
D. 선택 정렬   
   
40. 다음 중 누적 합 배열을 초기화할때 올바른 방식은? C   
A. S[0] = A[0]   
B. S[0] = 1   
C. S[0] = 0   
D. S[1] = A[1]   
   
   
## 풀이 및 정답   
● 단답형 정답   
1) 입력 크기 n이 커질수록 수행 시간이 n²에 비례함을 의미한다.   
2) 빅-오(Big-O) 표기법   
3) 배열은 연속된 메모리 공간, 리스트는 포인터로 연결된 구조   
4) S[j] - S[i - 1]   
5) 배열은 크기를 고정해서 선언하며, 연속된 공간을 사용하기 때문이다.   
6) 코드의 논리적, 문법적 오류를 수정하기 위해 필요하다.   
7) Break Point   
8) O(n²)   
9) O(n log n)   
10) 합 배열 또는 누적 합 배열   
11) O(n²)   
12) 시간 복잡도   
13) 같은 자료형   
14) 연결 구조로 중간 삽입/삭제가 용이하다   
15) 노드 (값 + 포인터)   
16) 구간 합을 O(1)에 구할 수 있다   
17) 누적 합(Prefix Sum)   
18) 0   
19) S[i] = S[i-1] + A[i]   
20) IndexError   
   
## ● 객관식 정답   
1) B   
2) B   
3) B   
4) B   
5) C   
6) D   
7) B   
8) C   
9) C   
10) D   
11) B   
12) D   
13) B   
14) C   
15) C   
16) C   
17) B   
18) A   
19) C      
20) C   

