# ğŸ“˜ ì •ë ¬   
## ê¸°ìˆ˜ì •ë ¬   
* ê°’ì„ ë†“ê³  ë¹„êµí•  ìë¦¿ìˆ˜ë¥¼ ì •í•œ ë‹¤ìŒ í•´ë‹¹ ìë¦¿ìˆ˜ë§Œ * ë¹„êµí•œë‹¤.   
* ë°ì´í„°ë¥¼ ë¹„êµí•˜ì§€ ì•ŠëŠ”ë‹¤.   
* íë¥¼ ì´ìš©í•œë‹¤.   
* ì‹œê°„ë³µì¡ë„ : O(kN)   
- k : ìë¦¿ìˆ˜   
- N : ë°ì´í„° ê°¯ìˆ˜   
* ì •ë ¬ëŒ€ìƒì´ ë§ê³  ìë¦¿ìˆ˜ê°€ ì‘ì„ë•Œ íš¨ìœ¨ì ì´ë‹¤.    
* ë°ì´í„° ê°¯ìˆ˜ê°€ ë§ì„ ìˆ˜ë¡, ìë¦¿ìˆ˜ê°€ ì¼ì •í•  ìˆ˜ë¡ ì†ë„ì™€ íš¨ìœ¨ì´ ë†’ë‹¤.   
   
## DFS : ê¹Šì´ ìš°ì„  íƒìƒ‰   
ì‹œì‘ë…¸ë“œì—ì„œ ì¶œë°œí•˜ì—¬ íƒìƒ‰í•  ìª½ ë¶„ê¸°ì„ ì •í•´ì•¼ ìµœëŒ€ ê¹Šì´ê¹Œì§€ íƒìƒ‰ì„ í•œë‹¤.   
íƒìƒ‰ì´ ëë‚œ ë¶„ê¸°ë¡œ ì´ë™í•˜ì—¬ ë‹¤ì‹œ íƒìƒ‰ì„ ìˆ˜í–‰í•œë‹¤.   
ë°©ë¬¸ì—¬ë¶€ ì²´í¬í•´ì•¼í•œë‹¤.boolean ë°°ì—´ ì‚¬ìš©í•˜ë©´ ëœë‹¤.   
ì¬ê·€í•¨ìˆ˜ ì‚¬ìš©ì‹œ ìŠ¤íƒì˜¤ë²„í”Œë¡œìš° ì£¼ì˜í•´ì•¼í•œë‹¤.   
ë°©ë¬¸ì—¬ë¶€ ì²´í¬   
ì˜ˆì œ - ì™¸íŒì› ë°©ë¬¸ ì•Œê³ ë¦¬ì¦˜   
   
## BFS : ë„“ì´ ìš°ì„  íƒìƒ‰   
ì¶œë°œë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ë¨¼ì € ë°©ë¬¸í•˜ë©´ì„œ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.   
   

## ê¸°ìˆ˜ì •ë ¬ ë¬¸ì œ

    /*
    ì…ë ¥
    11
    215
    15
    344
    372
    294
    100
    8
    145
    24
    198
    831 

    ì¶œë ¥
    8
    15
    24
    100
    145
    198
    215
    294
    344
    372
    831

    */
    
    import java.io.BufferedReader;
    import java.io.BufferedWriter;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.io.OutputStreamWriter;   

    public class Sort_gisu {

      public static int[] A;
      public static long result;
      
      public static void main(String[] args) throws NumberFormatException, IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int N = Integer.parseInt(br.readLine());
        A = new int[N];
        for(int i=0;i<N;i++) {
          A[i] = Integer.parseInt(br.readLine());
        }
        br.close();
        Radix_Sort(A, 5);
        for(int i=0;i<N;i++) {
          bw.write(A[i]+"\n");
        }
        bw.flush();
        bw.close();
        
      }
      public static void Radix_Sort(int[] A, int max_size) {
        int[] output = new int[A.length];
        System.out.println("output="+A.length);
        int jarisu = 1;
        int count = 0;
        while(count != max_size) { //ìµœëŒ€ ìë¦¿ìˆ˜ë§Œí¼ ë°˜ë³µí•˜ê¸°
          int[] bucket = new int[10];
          for(int i=0;i<A.length;i++) {
            bucket[(A[i]/jarisu) % 10]++; //ì¼ì˜ ìë¦¬ë¶€í„° ì‹œì‘í•˜ê¸°
          }
          for(int i=1;i<10;i++) { // í™ ë°°ì—´ì„ ì´ìš©í•´ index ê³„ì‚°í•˜ê¸°
            System.out.println("i="+i);
            bucket[i] += bucket[i-1];
          }
          for(int i=A.length-1;i>=0;i--) { //í˜„ì¬ ìë¦¿ìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê¸°
            output[bucket[(A[i]/jarisu %10)]-1]=A[i];
            bucket[(A[i]/jarisu)%10]--;
          }
          for(int i=0;i<A.length;i++) {
            //ë‹¤ìŒ ìë¦´ìˆ˜ë¥¼ ì´ë™í•˜ê¸° ìœ„í•´ í˜„ì¬ ìë¦¿ìˆ˜ ê¸°ì¤€ ì •ë ¬ ë°ì´í„° ì €ì¥í•˜ê¸°
            A[i] = output[i];
          }
          jarisu = jarisu*10; //ìë¦¿ìˆ˜ ì¦ê°€ì‹œí‚¤ê¸°
          count++;
          
        }
      }
    }


## DFS : ê¹Šì´ ìš°ì„  íƒìƒ‰ ë¬¸ì œ


    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.ArrayList;
    import java.util.StringTokenizer;
    /*
    ì…ë ¥
    6 5
    1 2
    2 5
    5 1
    3 4
    4 6 
    */
    public class Search_dfs {
      static ArrayList<Integer>[] A;
      static boolean visited[];
      public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        
        A = new ArrayList[n+1];
        visited = new boolean[n+1];
        
        for(int i=1;i<n+1;i++) {
          A[i] = new ArrayList<Integer>();
        }
        for(int i=0;i<m;i++) {
          st = new StringTokenizer(br.readLine());
          int s = Integer.parseInt(st.nextToken());
          int e = Integer.parseInt(st.nextToken());
          A[s].add(e);
          A[e].add(s);
        }
        int count = 0;
        for(int i=1;i<n+1;i++) {
          if(!visited[i]) {
            count++;
            DFS(i);
          }
        }
        System.out.println(count);
      }
      static void DFS(int v) {
        if(visited[v]) {
          return;
        }
        visited[v] = true;
        for(int i:A[v]) {
          if(visited[i] == false) {
            DFS(i);
          }
        }
      }

    }


## BFS : ë„“ì´ ìš°ì„  ë¬¸ì œ

    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.LinkedList;
    import java.util.Queue;
    import java.util.Scanner;
    /*
    ì…ë ¥
    4 5 1
    1 2
    1 3
    1 4
    2 4
    3 4

    ì¶œë ¥
    1 2 4 3 
    1 2 3 4 
    */
    public class Search_bfs {
      static boolean visited[];
      static ArrayList<Integer>[] A;
      public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int N = scan.nextInt();
        int M = scan.nextInt();
        int Start = scan.nextInt();
        
        A = new ArrayList[N+1];
        for(int i=1;i<=N;i++) {
          A[i] = new ArrayList<Integer>();
        }
        for(int i=0;i<M;i++) {
          int S = scan.nextInt();
          int E = scan.nextInt();
          A[S].add(E);
          A[E].add(S);
        }
        for(int i=1;i<=N;i++) {
          Collections.sort(A[i]);
        }
        visited = new boolean[N+1];
        DFS(Start);
        System.out.println();
        
        visited = new boolean[N+1];
        BFS(Start);
        System.out.println();
      }
      public static void DFS(int Node) {
        System.out.print(Node+" ");
        visited[Node] = true;
        for(int i:A[Node]) {
          if(!visited[i]) {
            DFS(i);
          }
        }
      }
      private static void BFS(int Node) {
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.add(Node);
        visited[Node] = true;
        
        while(!queue.isEmpty()) {
          int now_Node = queue.poll();
          System.out.print(now_Node+" ");
          for(int i : A[now_Node]) {
            if(!visited[i]) {
              visited[i] = true;
              queue.add(i);
            }
          }
        }
        
      }
      

    }



# âœ… ë¬¸ì œ

